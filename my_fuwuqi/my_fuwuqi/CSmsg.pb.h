// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSmsg.proto

#ifndef PROTOBUF_CSmsg_2eproto__INCLUDED
#define PROTOBUF_CSmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "DBmsg.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSmsg_2eproto();
void protobuf_AssignDesc_CSmsg_2eproto();
void protobuf_ShutdownFile_CSmsg_2eproto();

class CSLoginReq;
class CSLoginRsp;
class CSRegisterReq;
class CSRegisterRsp;
class CSQuitReq;
class CSRegisterLoginReqParam;
class CSRegisterLoginRspParam;
class CSRegisterLoginReq;
class CSRegisterLoginRsp;
class CSBagFetchReq;
class CSBagGridInfo;
class CSBagBagInfo;
class CSBagFetchRsp;
class CSBagUseReq;
class CSItemInfo;
class CSItemInfoList;
class CSBagUseRsp;
class CSBagReqParam;
class CSBagRspParam;
class CSBagReq;
class CSBagRsp;
class CSDecorateBagFetchReq;
class CSDecorateBagGridInfo;
class CSDecorateBagInfo;
class CSDecorateBagFetchRsp;
class CSDecorateBagShowSetReq;
class CSDecorateBagVIPFetchReq;
class CSDecorateBagVIPItem;
class CSDecorateBagVIPList;
class CSDecorateBagVIPFetchRsp;
class CSDecorateBagReqParam;
class CSDecorateBagRspParam;
class CSDecorateBagReq;
class CSDecorateBagRsp;
class CSMsgBody;
class CSMsgHead;
class CSMsg;

enum CSRegisterLoginCmd {
  CSRegisterLoginCmd_Register = 1,
  CSRegisterLoginCmd_Login = 2,
  CSRegisterLoginCmd_Quit = 3
};
bool CSRegisterLoginCmd_IsValid(int value);
const CSRegisterLoginCmd CSRegisterLoginCmd_MIN = CSRegisterLoginCmd_Register;
const CSRegisterLoginCmd CSRegisterLoginCmd_MAX = CSRegisterLoginCmd_Quit;
const int CSRegisterLoginCmd_ARRAYSIZE = CSRegisterLoginCmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* CSRegisterLoginCmd_descriptor();
inline const ::std::string& CSRegisterLoginCmd_Name(CSRegisterLoginCmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    CSRegisterLoginCmd_descriptor(), value);
}
inline bool CSRegisterLoginCmd_Parse(
    const ::std::string& name, CSRegisterLoginCmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CSRegisterLoginCmd>(
    CSRegisterLoginCmd_descriptor(), name, value);
}
enum CSBagCmd {
  CSBagCmd_Fetch = 1,
  CSBagCmd_Use = 2
};
bool CSBagCmd_IsValid(int value);
const CSBagCmd CSBagCmd_MIN = CSBagCmd_Fetch;
const CSBagCmd CSBagCmd_MAX = CSBagCmd_Use;
const int CSBagCmd_ARRAYSIZE = CSBagCmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* CSBagCmd_descriptor();
inline const ::std::string& CSBagCmd_Name(CSBagCmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    CSBagCmd_descriptor(), value);
}
inline bool CSBagCmd_Parse(
    const ::std::string& name, CSBagCmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CSBagCmd>(
    CSBagCmd_descriptor(), name, value);
}
enum CSDecorateBagCmd {
  CSDecorateBagCmd_Fetch = 1,
  CSDecorateBagCmd_ShowSet = 2,
  CSDecorateBagCmd_VipFetch = 3
};
bool CSDecorateBagCmd_IsValid(int value);
const CSDecorateBagCmd CSDecorateBagCmd_MIN = CSDecorateBagCmd_Fetch;
const CSDecorateBagCmd CSDecorateBagCmd_MAX = CSDecorateBagCmd_VipFetch;
const int CSDecorateBagCmd_ARRAYSIZE = CSDecorateBagCmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* CSDecorateBagCmd_descriptor();
inline const ::std::string& CSDecorateBagCmd_Name(CSDecorateBagCmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    CSDecorateBagCmd_descriptor(), value);
}
inline bool CSDecorateBagCmd_Parse(
    const ::std::string& name, CSDecorateBagCmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CSDecorateBagCmd>(
    CSDecorateBagCmd_descriptor(), name, value);
}
enum CSMsgID {
  CS_MSGID_MIN = 0,
  CS_MSGID_RegisterLogin = 1,
  CS_MSGID_BAG = 2,
  CS_MSGID_DecorateBAG = 3,
  CS_MSGID_MAX = 4
};
bool CSMsgID_IsValid(int value);
const CSMsgID CSMsgID_MIN = CS_MSGID_MIN;
const CSMsgID CSMsgID_MAX = CS_MSGID_MAX;
const int CSMsgID_ARRAYSIZE = CSMsgID_MAX + 1;

const ::google::protobuf::EnumDescriptor* CSMsgID_descriptor();
inline const ::std::string& CSMsgID_Name(CSMsgID value) {
  return ::google::protobuf::internal::NameOfEnum(
    CSMsgID_descriptor(), value);
}
inline bool CSMsgID_Parse(
    const ::std::string& name, CSMsgID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CSMsgID>(
    CSMsgID_descriptor(), name, value);
}
// ===================================================================

class CSLoginReq : public ::google::protobuf::Message {
 public:
  CSLoginReq();
  virtual ~CSLoginReq();

  CSLoginReq(const CSLoginReq& from);

  inline CSLoginReq& operator=(const CSLoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSLoginReq& default_instance();

  void Swap(CSLoginReq* other);

  // implements Message ----------------------------------------------

  CSLoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSLoginReq& from);
  void MergeFrom(const CSLoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:CSLoginReq)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSLoginReq* default_instance_;
};
// -------------------------------------------------------------------

class CSLoginRsp : public ::google::protobuf::Message {
 public:
  CSLoginRsp();
  virtual ~CSLoginRsp();

  CSLoginRsp(const CSLoginRsp& from);

  inline CSLoginRsp& operator=(const CSLoginRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSLoginRsp& default_instance();

  void Swap(CSLoginRsp* other);

  // implements Message ----------------------------------------------

  CSLoginRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSLoginRsp& from);
  void MergeFrom(const CSLoginRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional .DBRoleInfo Role = 2;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 2;
  inline const ::DBRoleInfo& role() const;
  inline ::DBRoleInfo* mutable_role();
  inline ::DBRoleInfo* release_role();
  inline void set_allocated_role(::DBRoleInfo* role);

  // @@protoc_insertion_point(class_scope:CSLoginRsp)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_role();
  inline void clear_has_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::DBRoleInfo* role_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSLoginRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSRegisterReq : public ::google::protobuf::Message {
 public:
  CSRegisterReq();
  virtual ~CSRegisterReq();

  CSRegisterReq(const CSRegisterReq& from);

  inline CSRegisterReq& operator=(const CSRegisterReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSRegisterReq& default_instance();

  void Swap(CSRegisterReq* other);

  // implements Message ----------------------------------------------

  CSRegisterReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSRegisterReq& from);
  void MergeFrom(const CSRegisterReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:CSRegisterReq)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* password_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSRegisterReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRegisterRsp : public ::google::protobuf::Message {
 public:
  CSRegisterRsp();
  virtual ~CSRegisterRsp();

  CSRegisterRsp(const CSRegisterRsp& from);

  inline CSRegisterRsp& operator=(const CSRegisterRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSRegisterRsp& default_instance();

  void Swap(CSRegisterRsp* other);

  // implements Message ----------------------------------------------

  CSRegisterRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSRegisterRsp& from);
  void MergeFrom(const CSRegisterRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CSRegisterRsp)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSRegisterRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSQuitReq : public ::google::protobuf::Message {
 public:
  CSQuitReq();
  virtual ~CSQuitReq();

  CSQuitReq(const CSQuitReq& from);

  inline CSQuitReq& operator=(const CSQuitReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSQuitReq& default_instance();

  void Swap(CSQuitReq* other);

  // implements Message ----------------------------------------------

  CSQuitReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSQuitReq& from);
  void MergeFrom(const CSQuitReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 pad = 1;
  inline bool has_pad() const;
  inline void clear_pad();
  static const int kPadFieldNumber = 1;
  inline ::google::protobuf::uint32 pad() const;
  inline void set_pad(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CSQuitReq)
 private:
  inline void set_has_pad();
  inline void clear_has_pad();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 pad_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSQuitReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRegisterLoginReqParam : public ::google::protobuf::Message {
 public:
  CSRegisterLoginReqParam();
  virtual ~CSRegisterLoginReqParam();

  CSRegisterLoginReqParam(const CSRegisterLoginReqParam& from);

  inline CSRegisterLoginReqParam& operator=(const CSRegisterLoginReqParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSRegisterLoginReqParam& default_instance();

  void Swap(CSRegisterLoginReqParam* other);

  // implements Message ----------------------------------------------

  CSRegisterLoginReqParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSRegisterLoginReqParam& from);
  void MergeFrom(const CSRegisterLoginReqParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CSLoginReq LoginReq = 1;
  inline bool has_loginreq() const;
  inline void clear_loginreq();
  static const int kLoginReqFieldNumber = 1;
  inline const ::CSLoginReq& loginreq() const;
  inline ::CSLoginReq* mutable_loginreq();
  inline ::CSLoginReq* release_loginreq();
  inline void set_allocated_loginreq(::CSLoginReq* loginreq);

  // optional .CSRegisterReq RegisterReq = 2;
  inline bool has_registerreq() const;
  inline void clear_registerreq();
  static const int kRegisterReqFieldNumber = 2;
  inline const ::CSRegisterReq& registerreq() const;
  inline ::CSRegisterReq* mutable_registerreq();
  inline ::CSRegisterReq* release_registerreq();
  inline void set_allocated_registerreq(::CSRegisterReq* registerreq);

  // optional .CSQuitReq QuitReq = 3;
  inline bool has_quitreq() const;
  inline void clear_quitreq();
  static const int kQuitReqFieldNumber = 3;
  inline const ::CSQuitReq& quitreq() const;
  inline ::CSQuitReq* mutable_quitreq();
  inline ::CSQuitReq* release_quitreq();
  inline void set_allocated_quitreq(::CSQuitReq* quitreq);

  // @@protoc_insertion_point(class_scope:CSRegisterLoginReqParam)
 private:
  inline void set_has_loginreq();
  inline void clear_has_loginreq();
  inline void set_has_registerreq();
  inline void clear_has_registerreq();
  inline void set_has_quitreq();
  inline void clear_has_quitreq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSLoginReq* loginreq_;
  ::CSRegisterReq* registerreq_;
  ::CSQuitReq* quitreq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSRegisterLoginReqParam* default_instance_;
};
// -------------------------------------------------------------------

class CSRegisterLoginRspParam : public ::google::protobuf::Message {
 public:
  CSRegisterLoginRspParam();
  virtual ~CSRegisterLoginRspParam();

  CSRegisterLoginRspParam(const CSRegisterLoginRspParam& from);

  inline CSRegisterLoginRspParam& operator=(const CSRegisterLoginRspParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSRegisterLoginRspParam& default_instance();

  void Swap(CSRegisterLoginRspParam* other);

  // implements Message ----------------------------------------------

  CSRegisterLoginRspParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSRegisterLoginRspParam& from);
  void MergeFrom(const CSRegisterLoginRspParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CSLoginRsp LoginRsp = 1;
  inline bool has_loginrsp() const;
  inline void clear_loginrsp();
  static const int kLoginRspFieldNumber = 1;
  inline const ::CSLoginRsp& loginrsp() const;
  inline ::CSLoginRsp* mutable_loginrsp();
  inline ::CSLoginRsp* release_loginrsp();
  inline void set_allocated_loginrsp(::CSLoginRsp* loginrsp);

  // optional .CSRegisterRsp RegisterRsp = 2;
  inline bool has_registerrsp() const;
  inline void clear_registerrsp();
  static const int kRegisterRspFieldNumber = 2;
  inline const ::CSRegisterRsp& registerrsp() const;
  inline ::CSRegisterRsp* mutable_registerrsp();
  inline ::CSRegisterRsp* release_registerrsp();
  inline void set_allocated_registerrsp(::CSRegisterRsp* registerrsp);

  // @@protoc_insertion_point(class_scope:CSRegisterLoginRspParam)
 private:
  inline void set_has_loginrsp();
  inline void clear_has_loginrsp();
  inline void set_has_registerrsp();
  inline void clear_has_registerrsp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSLoginRsp* loginrsp_;
  ::CSRegisterRsp* registerrsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSRegisterLoginRspParam* default_instance_;
};
// -------------------------------------------------------------------

class CSRegisterLoginReq : public ::google::protobuf::Message {
 public:
  CSRegisterLoginReq();
  virtual ~CSRegisterLoginReq();

  CSRegisterLoginReq(const CSRegisterLoginReq& from);

  inline CSRegisterLoginReq& operator=(const CSRegisterLoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSRegisterLoginReq& default_instance();

  void Swap(CSRegisterLoginReq* other);

  // implements Message ----------------------------------------------

  CSRegisterLoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSRegisterLoginReq& from);
  void MergeFrom(const CSRegisterLoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CSRegisterLoginCmd cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::CSRegisterLoginCmd cmd() const;
  inline void set_cmd(::CSRegisterLoginCmd value);

  // optional .CSRegisterLoginReqParam reqParam = 2;
  inline bool has_reqparam() const;
  inline void clear_reqparam();
  static const int kReqParamFieldNumber = 2;
  inline const ::CSRegisterLoginReqParam& reqparam() const;
  inline ::CSRegisterLoginReqParam* mutable_reqparam();
  inline ::CSRegisterLoginReqParam* release_reqparam();
  inline void set_allocated_reqparam(::CSRegisterLoginReqParam* reqparam);

  // @@protoc_insertion_point(class_scope:CSRegisterLoginReq)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_reqparam();
  inline void clear_has_reqparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSRegisterLoginReqParam* reqparam_;
  int cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSRegisterLoginReq* default_instance_;
};
// -------------------------------------------------------------------

class CSRegisterLoginRsp : public ::google::protobuf::Message {
 public:
  CSRegisterLoginRsp();
  virtual ~CSRegisterLoginRsp();

  CSRegisterLoginRsp(const CSRegisterLoginRsp& from);

  inline CSRegisterLoginRsp& operator=(const CSRegisterLoginRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSRegisterLoginRsp& default_instance();

  void Swap(CSRegisterLoginRsp* other);

  // implements Message ----------------------------------------------

  CSRegisterLoginRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSRegisterLoginRsp& from);
  void MergeFrom(const CSRegisterLoginRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required .CSRegisterLoginCmd cmd = 2;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 2;
  inline ::CSRegisterLoginCmd cmd() const;
  inline void set_cmd(::CSRegisterLoginCmd value);

  // optional .CSRegisterLoginRspParam rspParam = 3;
  inline bool has_rspparam() const;
  inline void clear_rspparam();
  static const int kRspParamFieldNumber = 3;
  inline const ::CSRegisterLoginRspParam& rspparam() const;
  inline ::CSRegisterLoginRspParam* mutable_rspparam();
  inline ::CSRegisterLoginRspParam* release_rspparam();
  inline void set_allocated_rspparam(::CSRegisterLoginRspParam* rspparam);

  // @@protoc_insertion_point(class_scope:CSRegisterLoginRsp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_rspparam();
  inline void clear_has_rspparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;
  int cmd_;
  ::CSRegisterLoginRspParam* rspparam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSRegisterLoginRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSBagFetchReq : public ::google::protobuf::Message {
 public:
  CSBagFetchReq();
  virtual ~CSBagFetchReq();

  CSBagFetchReq(const CSBagFetchReq& from);

  inline CSBagFetchReq& operator=(const CSBagFetchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSBagFetchReq& default_instance();

  void Swap(CSBagFetchReq* other);

  // implements Message ----------------------------------------------

  CSBagFetchReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSBagFetchReq& from);
  void MergeFrom(const CSBagFetchReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 pad = 1;
  inline bool has_pad() const;
  inline void clear_pad();
  static const int kPadFieldNumber = 1;
  inline ::google::protobuf::uint32 pad() const;
  inline void set_pad(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CSBagFetchReq)
 private:
  inline void set_has_pad();
  inline void clear_has_pad();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 pad_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagFetchReq* default_instance_;
};
// -------------------------------------------------------------------

class CSBagGridInfo : public ::google::protobuf::Message {
 public:
  CSBagGridInfo();
  virtual ~CSBagGridInfo();

  CSBagGridInfo(const CSBagGridInfo& from);

  inline CSBagGridInfo& operator=(const CSBagGridInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSBagGridInfo& default_instance();

  void Swap(CSBagGridInfo* other);

  // implements Message ----------------------------------------------

  CSBagGridInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSBagGridInfo& from);
  void MergeFrom(const CSBagGridInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ItemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // optional uint32 Num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CSBagGridInfo)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagGridInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSBagBagInfo : public ::google::protobuf::Message {
 public:
  CSBagBagInfo();
  virtual ~CSBagBagInfo();

  CSBagBagInfo(const CSBagBagInfo& from);

  inline CSBagBagInfo& operator=(const CSBagBagInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSBagBagInfo& default_instance();

  void Swap(CSBagBagInfo* other);

  // implements Message ----------------------------------------------

  CSBagBagInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSBagBagInfo& from);
  void MergeFrom(const CSBagBagInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CSBagGridInfo GridInfo = 1;
  inline int gridinfo_size() const;
  inline void clear_gridinfo();
  static const int kGridInfoFieldNumber = 1;
  inline const ::CSBagGridInfo& gridinfo(int index) const;
  inline ::CSBagGridInfo* mutable_gridinfo(int index);
  inline ::CSBagGridInfo* add_gridinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::CSBagGridInfo >&
      gridinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::CSBagGridInfo >*
      mutable_gridinfo();

  // @@protoc_insertion_point(class_scope:CSBagBagInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::CSBagGridInfo > gridinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagBagInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSBagFetchRsp : public ::google::protobuf::Message {
 public:
  CSBagFetchRsp();
  virtual ~CSBagFetchRsp();

  CSBagFetchRsp(const CSBagFetchRsp& from);

  inline CSBagFetchRsp& operator=(const CSBagFetchRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSBagFetchRsp& default_instance();

  void Swap(CSBagFetchRsp* other);

  // implements Message ----------------------------------------------

  CSBagFetchRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSBagFetchRsp& from);
  void MergeFrom(const CSBagFetchRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CSBagBagInfo BagInfo = 1;
  inline bool has_baginfo() const;
  inline void clear_baginfo();
  static const int kBagInfoFieldNumber = 1;
  inline const ::CSBagBagInfo& baginfo() const;
  inline ::CSBagBagInfo* mutable_baginfo();
  inline ::CSBagBagInfo* release_baginfo();
  inline void set_allocated_baginfo(::CSBagBagInfo* baginfo);

  // @@protoc_insertion_point(class_scope:CSBagFetchRsp)
 private:
  inline void set_has_baginfo();
  inline void clear_has_baginfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSBagBagInfo* baginfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagFetchRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSBagUseReq : public ::google::protobuf::Message {
 public:
  CSBagUseReq();
  virtual ~CSBagUseReq();

  CSBagUseReq(const CSBagUseReq& from);

  inline CSBagUseReq& operator=(const CSBagUseReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSBagUseReq& default_instance();

  void Swap(CSBagUseReq* other);

  // implements Message ----------------------------------------------

  CSBagUseReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSBagUseReq& from);
  void MergeFrom(const CSBagUseReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ItemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // optional uint32 ItemNum = 2;
  inline bool has_itemnum() const;
  inline void clear_itemnum();
  static const int kItemNumFieldNumber = 2;
  inline ::google::protobuf::uint32 itemnum() const;
  inline void set_itemnum(::google::protobuf::uint32 value);

  // optional uint32 PickedId = 3;
  inline bool has_pickedid() const;
  inline void clear_pickedid();
  static const int kPickedIdFieldNumber = 3;
  inline ::google::protobuf::uint32 pickedid() const;
  inline void set_pickedid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CSBagUseReq)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_itemnum();
  inline void clear_has_itemnum();
  inline void set_has_pickedid();
  inline void clear_has_pickedid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 itemnum_;
  ::google::protobuf::uint32 pickedid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagUseReq* default_instance_;
};
// -------------------------------------------------------------------

class CSItemInfo : public ::google::protobuf::Message {
 public:
  CSItemInfo();
  virtual ~CSItemInfo();

  CSItemInfo(const CSItemInfo& from);

  inline CSItemInfo& operator=(const CSItemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSItemInfo& default_instance();

  void Swap(CSItemInfo* other);

  // implements Message ----------------------------------------------

  CSItemInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSItemInfo& from);
  void MergeFrom(const CSItemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CSItemInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSItemInfoList : public ::google::protobuf::Message {
 public:
  CSItemInfoList();
  virtual ~CSItemInfoList();

  CSItemInfoList(const CSItemInfoList& from);

  inline CSItemInfoList& operator=(const CSItemInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSItemInfoList& default_instance();

  void Swap(CSItemInfoList* other);

  // implements Message ----------------------------------------------

  CSItemInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSItemInfoList& from);
  void MergeFrom(const CSItemInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CSItemInfo ItemInfo = 1;
  inline int iteminfo_size() const;
  inline void clear_iteminfo();
  static const int kItemInfoFieldNumber = 1;
  inline const ::CSItemInfo& iteminfo(int index) const;
  inline ::CSItemInfo* mutable_iteminfo(int index);
  inline ::CSItemInfo* add_iteminfo();
  inline const ::google::protobuf::RepeatedPtrField< ::CSItemInfo >&
      iteminfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::CSItemInfo >*
      mutable_iteminfo();

  // @@protoc_insertion_point(class_scope:CSItemInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::CSItemInfo > iteminfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSItemInfoList* default_instance_;
};
// -------------------------------------------------------------------

class CSBagUseRsp : public ::google::protobuf::Message {
 public:
  CSBagUseRsp();
  virtual ~CSBagUseRsp();

  CSBagUseRsp(const CSBagUseRsp& from);

  inline CSBagUseRsp& operator=(const CSBagUseRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSBagUseRsp& default_instance();

  void Swap(CSBagUseRsp* other);

  // implements Message ----------------------------------------------

  CSBagUseRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSBagUseRsp& from);
  void MergeFrom(const CSBagUseRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CSItemInfoList ItemInfoList = 1;
  inline bool has_iteminfolist() const;
  inline void clear_iteminfolist();
  static const int kItemInfoListFieldNumber = 1;
  inline const ::CSItemInfoList& iteminfolist() const;
  inline ::CSItemInfoList* mutable_iteminfolist();
  inline ::CSItemInfoList* release_iteminfolist();
  inline void set_allocated_iteminfolist(::CSItemInfoList* iteminfolist);

  // @@protoc_insertion_point(class_scope:CSBagUseRsp)
 private:
  inline void set_has_iteminfolist();
  inline void clear_has_iteminfolist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSItemInfoList* iteminfolist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagUseRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSBagReqParam : public ::google::protobuf::Message {
 public:
  CSBagReqParam();
  virtual ~CSBagReqParam();

  CSBagReqParam(const CSBagReqParam& from);

  inline CSBagReqParam& operator=(const CSBagReqParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSBagReqParam& default_instance();

  void Swap(CSBagReqParam* other);

  // implements Message ----------------------------------------------

  CSBagReqParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSBagReqParam& from);
  void MergeFrom(const CSBagReqParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CSBagFetchReq FetchReq = 1;
  inline bool has_fetchreq() const;
  inline void clear_fetchreq();
  static const int kFetchReqFieldNumber = 1;
  inline const ::CSBagFetchReq& fetchreq() const;
  inline ::CSBagFetchReq* mutable_fetchreq();
  inline ::CSBagFetchReq* release_fetchreq();
  inline void set_allocated_fetchreq(::CSBagFetchReq* fetchreq);

  // optional .CSBagUseReq UseReq = 2;
  inline bool has_usereq() const;
  inline void clear_usereq();
  static const int kUseReqFieldNumber = 2;
  inline const ::CSBagUseReq& usereq() const;
  inline ::CSBagUseReq* mutable_usereq();
  inline ::CSBagUseReq* release_usereq();
  inline void set_allocated_usereq(::CSBagUseReq* usereq);

  // @@protoc_insertion_point(class_scope:CSBagReqParam)
 private:
  inline void set_has_fetchreq();
  inline void clear_has_fetchreq();
  inline void set_has_usereq();
  inline void clear_has_usereq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSBagFetchReq* fetchreq_;
  ::CSBagUseReq* usereq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagReqParam* default_instance_;
};
// -------------------------------------------------------------------

class CSBagRspParam : public ::google::protobuf::Message {
 public:
  CSBagRspParam();
  virtual ~CSBagRspParam();

  CSBagRspParam(const CSBagRspParam& from);

  inline CSBagRspParam& operator=(const CSBagRspParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSBagRspParam& default_instance();

  void Swap(CSBagRspParam* other);

  // implements Message ----------------------------------------------

  CSBagRspParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSBagRspParam& from);
  void MergeFrom(const CSBagRspParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CSBagFetchRsp FetchRsp = 1;
  inline bool has_fetchrsp() const;
  inline void clear_fetchrsp();
  static const int kFetchRspFieldNumber = 1;
  inline const ::CSBagFetchRsp& fetchrsp() const;
  inline ::CSBagFetchRsp* mutable_fetchrsp();
  inline ::CSBagFetchRsp* release_fetchrsp();
  inline void set_allocated_fetchrsp(::CSBagFetchRsp* fetchrsp);

  // optional .CSBagUseRsp UseRsp = 2;
  inline bool has_usersp() const;
  inline void clear_usersp();
  static const int kUseRspFieldNumber = 2;
  inline const ::CSBagUseRsp& usersp() const;
  inline ::CSBagUseRsp* mutable_usersp();
  inline ::CSBagUseRsp* release_usersp();
  inline void set_allocated_usersp(::CSBagUseRsp* usersp);

  // @@protoc_insertion_point(class_scope:CSBagRspParam)
 private:
  inline void set_has_fetchrsp();
  inline void clear_has_fetchrsp();
  inline void set_has_usersp();
  inline void clear_has_usersp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSBagFetchRsp* fetchrsp_;
  ::CSBagUseRsp* usersp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagRspParam* default_instance_;
};
// -------------------------------------------------------------------

class CSBagReq : public ::google::protobuf::Message {
 public:
  CSBagReq();
  virtual ~CSBagReq();

  CSBagReq(const CSBagReq& from);

  inline CSBagReq& operator=(const CSBagReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSBagReq& default_instance();

  void Swap(CSBagReq* other);

  // implements Message ----------------------------------------------

  CSBagReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSBagReq& from);
  void MergeFrom(const CSBagReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CSBagCmd cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::CSBagCmd cmd() const;
  inline void set_cmd(::CSBagCmd value);

  // optional .CSBagReqParam reqParam = 2;
  inline bool has_reqparam() const;
  inline void clear_reqparam();
  static const int kReqParamFieldNumber = 2;
  inline const ::CSBagReqParam& reqparam() const;
  inline ::CSBagReqParam* mutable_reqparam();
  inline ::CSBagReqParam* release_reqparam();
  inline void set_allocated_reqparam(::CSBagReqParam* reqparam);

  // @@protoc_insertion_point(class_scope:CSBagReq)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_reqparam();
  inline void clear_has_reqparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSBagReqParam* reqparam_;
  int cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagReq* default_instance_;
};
// -------------------------------------------------------------------

class CSBagRsp : public ::google::protobuf::Message {
 public:
  CSBagRsp();
  virtual ~CSBagRsp();

  CSBagRsp(const CSBagRsp& from);

  inline CSBagRsp& operator=(const CSBagRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSBagRsp& default_instance();

  void Swap(CSBagRsp* other);

  // implements Message ----------------------------------------------

  CSBagRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSBagRsp& from);
  void MergeFrom(const CSBagRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required .CSBagCmd cmd = 2;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 2;
  inline ::CSBagCmd cmd() const;
  inline void set_cmd(::CSBagCmd value);

  // optional .CSBagRspParam rspParam = 3;
  inline bool has_rspparam() const;
  inline void clear_rspparam();
  static const int kRspParamFieldNumber = 3;
  inline const ::CSBagRspParam& rspparam() const;
  inline ::CSBagRspParam* mutable_rspparam();
  inline ::CSBagRspParam* release_rspparam();
  inline void set_allocated_rspparam(::CSBagRspParam* rspparam);

  // @@protoc_insertion_point(class_scope:CSBagRsp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_rspparam();
  inline void clear_has_rspparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;
  int cmd_;
  ::CSBagRspParam* rspparam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSDecorateBagFetchReq : public ::google::protobuf::Message {
 public:
  CSDecorateBagFetchReq();
  virtual ~CSDecorateBagFetchReq();

  CSDecorateBagFetchReq(const CSDecorateBagFetchReq& from);

  inline CSDecorateBagFetchReq& operator=(const CSDecorateBagFetchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSDecorateBagFetchReq& default_instance();

  void Swap(CSDecorateBagFetchReq* other);

  // implements Message ----------------------------------------------

  CSDecorateBagFetchReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSDecorateBagFetchReq& from);
  void MergeFrom(const CSDecorateBagFetchReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CSDecorateBagFetchReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSDecorateBagFetchReq* default_instance_;
};
// -------------------------------------------------------------------

class CSDecorateBagGridInfo : public ::google::protobuf::Message {
 public:
  CSDecorateBagGridInfo();
  virtual ~CSDecorateBagGridInfo();

  CSDecorateBagGridInfo(const CSDecorateBagGridInfo& from);

  inline CSDecorateBagGridInfo& operator=(const CSDecorateBagGridInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSDecorateBagGridInfo& default_instance();

  void Swap(CSDecorateBagGridInfo* other);

  // implements Message ----------------------------------------------

  CSDecorateBagGridInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSDecorateBagGridInfo& from);
  void MergeFrom(const CSDecorateBagGridInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ItemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint64 EndTime = 3;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 endtime() const;
  inline void set_endtime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CSDecorateBagGridInfo)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint64 endtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSDecorateBagGridInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSDecorateBagInfo : public ::google::protobuf::Message {
 public:
  CSDecorateBagInfo();
  virtual ~CSDecorateBagInfo();

  CSDecorateBagInfo(const CSDecorateBagInfo& from);

  inline CSDecorateBagInfo& operator=(const CSDecorateBagInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSDecorateBagInfo& default_instance();

  void Swap(CSDecorateBagInfo* other);

  // implements Message ----------------------------------------------

  CSDecorateBagInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSDecorateBagInfo& from);
  void MergeFrom(const CSDecorateBagInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CSDecorateBagGridInfo DecorateGridInfo = 1;
  inline int decorategridinfo_size() const;
  inline void clear_decorategridinfo();
  static const int kDecorateGridInfoFieldNumber = 1;
  inline const ::CSDecorateBagGridInfo& decorategridinfo(int index) const;
  inline ::CSDecorateBagGridInfo* mutable_decorategridinfo(int index);
  inline ::CSDecorateBagGridInfo* add_decorategridinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::CSDecorateBagGridInfo >&
      decorategridinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::CSDecorateBagGridInfo >*
      mutable_decorategridinfo();

  // @@protoc_insertion_point(class_scope:CSDecorateBagInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::CSDecorateBagGridInfo > decorategridinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSDecorateBagInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSDecorateBagFetchRsp : public ::google::protobuf::Message {
 public:
  CSDecorateBagFetchRsp();
  virtual ~CSDecorateBagFetchRsp();

  CSDecorateBagFetchRsp(const CSDecorateBagFetchRsp& from);

  inline CSDecorateBagFetchRsp& operator=(const CSDecorateBagFetchRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSDecorateBagFetchRsp& default_instance();

  void Swap(CSDecorateBagFetchRsp* other);

  // implements Message ----------------------------------------------

  CSDecorateBagFetchRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSDecorateBagFetchRsp& from);
  void MergeFrom(const CSDecorateBagFetchRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional .CSDecorateBagInfo DecorateBagInfo = 3;
  inline bool has_decoratebaginfo() const;
  inline void clear_decoratebaginfo();
  static const int kDecorateBagInfoFieldNumber = 3;
  inline const ::CSDecorateBagInfo& decoratebaginfo() const;
  inline ::CSDecorateBagInfo* mutable_decoratebaginfo();
  inline ::CSDecorateBagInfo* release_decoratebaginfo();
  inline void set_allocated_decoratebaginfo(::CSDecorateBagInfo* decoratebaginfo);

  // @@protoc_insertion_point(class_scope:CSDecorateBagFetchRsp)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_decoratebaginfo();
  inline void clear_has_decoratebaginfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 id_;
  ::CSDecorateBagInfo* decoratebaginfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSDecorateBagFetchRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSDecorateBagShowSetReq : public ::google::protobuf::Message {
 public:
  CSDecorateBagShowSetReq();
  virtual ~CSDecorateBagShowSetReq();

  CSDecorateBagShowSetReq(const CSDecorateBagShowSetReq& from);

  inline CSDecorateBagShowSetReq& operator=(const CSDecorateBagShowSetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSDecorateBagShowSetReq& default_instance();

  void Swap(CSDecorateBagShowSetReq* other);

  // implements Message ----------------------------------------------

  CSDecorateBagShowSetReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSDecorateBagShowSetReq& from);
  void MergeFrom(const CSDecorateBagShowSetReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CSDecorateBagShowSetReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSDecorateBagShowSetReq* default_instance_;
};
// -------------------------------------------------------------------

class CSDecorateBagVIPFetchReq : public ::google::protobuf::Message {
 public:
  CSDecorateBagVIPFetchReq();
  virtual ~CSDecorateBagVIPFetchReq();

  CSDecorateBagVIPFetchReq(const CSDecorateBagVIPFetchReq& from);

  inline CSDecorateBagVIPFetchReq& operator=(const CSDecorateBagVIPFetchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSDecorateBagVIPFetchReq& default_instance();

  void Swap(CSDecorateBagVIPFetchReq* other);

  // implements Message ----------------------------------------------

  CSDecorateBagVIPFetchReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSDecorateBagVIPFetchReq& from);
  void MergeFrom(const CSDecorateBagVIPFetchReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CSDecorateBagVIPFetchReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSDecorateBagVIPFetchReq* default_instance_;
};
// -------------------------------------------------------------------

class CSDecorateBagVIPItem : public ::google::protobuf::Message {
 public:
  CSDecorateBagVIPItem();
  virtual ~CSDecorateBagVIPItem();

  CSDecorateBagVIPItem(const CSDecorateBagVIPItem& from);

  inline CSDecorateBagVIPItem& operator=(const CSDecorateBagVIPItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSDecorateBagVIPItem& default_instance();

  void Swap(CSDecorateBagVIPItem* other);

  // implements Message ----------------------------------------------

  CSDecorateBagVIPItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSDecorateBagVIPItem& from);
  void MergeFrom(const CSDecorateBagVIPItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 VipGread = 1;
  inline bool has_vipgread() const;
  inline void clear_vipgread();
  static const int kVipGreadFieldNumber = 1;
  inline ::google::protobuf::uint32 vipgread() const;
  inline void set_vipgread(::google::protobuf::uint32 value);

  // optional uint32 VipExper = 2;
  inline bool has_vipexper() const;
  inline void clear_vipexper();
  static const int kVipExperFieldNumber = 2;
  inline ::google::protobuf::uint32 vipexper() const;
  inline void set_vipexper(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CSDecorateBagVIPItem)
 private:
  inline void set_has_vipgread();
  inline void clear_has_vipgread();
  inline void set_has_vipexper();
  inline void clear_has_vipexper();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 vipgread_;
  ::google::protobuf::uint32 vipexper_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSDecorateBagVIPItem* default_instance_;
};
// -------------------------------------------------------------------

class CSDecorateBagVIPList : public ::google::protobuf::Message {
 public:
  CSDecorateBagVIPList();
  virtual ~CSDecorateBagVIPList();

  CSDecorateBagVIPList(const CSDecorateBagVIPList& from);

  inline CSDecorateBagVIPList& operator=(const CSDecorateBagVIPList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSDecorateBagVIPList& default_instance();

  void Swap(CSDecorateBagVIPList* other);

  // implements Message ----------------------------------------------

  CSDecorateBagVIPList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSDecorateBagVIPList& from);
  void MergeFrom(const CSDecorateBagVIPList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CSDecorateBagVIPItem VIPItemList = 1;
  inline int vipitemlist_size() const;
  inline void clear_vipitemlist();
  static const int kVIPItemListFieldNumber = 1;
  inline const ::CSDecorateBagVIPItem& vipitemlist(int index) const;
  inline ::CSDecorateBagVIPItem* mutable_vipitemlist(int index);
  inline ::CSDecorateBagVIPItem* add_vipitemlist();
  inline const ::google::protobuf::RepeatedPtrField< ::CSDecorateBagVIPItem >&
      vipitemlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::CSDecorateBagVIPItem >*
      mutable_vipitemlist();

  // @@protoc_insertion_point(class_scope:CSDecorateBagVIPList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::CSDecorateBagVIPItem > vipitemlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSDecorateBagVIPList* default_instance_;
};
// -------------------------------------------------------------------

class CSDecorateBagVIPFetchRsp : public ::google::protobuf::Message {
 public:
  CSDecorateBagVIPFetchRsp();
  virtual ~CSDecorateBagVIPFetchRsp();

  CSDecorateBagVIPFetchRsp(const CSDecorateBagVIPFetchRsp& from);

  inline CSDecorateBagVIPFetchRsp& operator=(const CSDecorateBagVIPFetchRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSDecorateBagVIPFetchRsp& default_instance();

  void Swap(CSDecorateBagVIPFetchRsp* other);

  // implements Message ----------------------------------------------

  CSDecorateBagVIPFetchRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSDecorateBagVIPFetchRsp& from);
  void MergeFrom(const CSDecorateBagVIPFetchRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional .CSDecorateBagInfo DecorateBagInfo = 3;
  inline bool has_decoratebaginfo() const;
  inline void clear_decoratebaginfo();
  static const int kDecorateBagInfoFieldNumber = 3;
  inline const ::CSDecorateBagInfo& decoratebaginfo() const;
  inline ::CSDecorateBagInfo* mutable_decoratebaginfo();
  inline ::CSDecorateBagInfo* release_decoratebaginfo();
  inline void set_allocated_decoratebaginfo(::CSDecorateBagInfo* decoratebaginfo);

  // optional .CSDecorateBagVIPList VipList = 4;
  inline bool has_viplist() const;
  inline void clear_viplist();
  static const int kVipListFieldNumber = 4;
  inline const ::CSDecorateBagVIPList& viplist() const;
  inline ::CSDecorateBagVIPList* mutable_viplist();
  inline ::CSDecorateBagVIPList* release_viplist();
  inline void set_allocated_viplist(::CSDecorateBagVIPList* viplist);

  // @@protoc_insertion_point(class_scope:CSDecorateBagVIPFetchRsp)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_decoratebaginfo();
  inline void clear_has_decoratebaginfo();
  inline void set_has_viplist();
  inline void clear_has_viplist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 id_;
  ::CSDecorateBagInfo* decoratebaginfo_;
  ::CSDecorateBagVIPList* viplist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSDecorateBagVIPFetchRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSDecorateBagReqParam : public ::google::protobuf::Message {
 public:
  CSDecorateBagReqParam();
  virtual ~CSDecorateBagReqParam();

  CSDecorateBagReqParam(const CSDecorateBagReqParam& from);

  inline CSDecorateBagReqParam& operator=(const CSDecorateBagReqParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSDecorateBagReqParam& default_instance();

  void Swap(CSDecorateBagReqParam* other);

  // implements Message ----------------------------------------------

  CSDecorateBagReqParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSDecorateBagReqParam& from);
  void MergeFrom(const CSDecorateBagReqParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CSDecorateBagFetchReq FetchReq = 1;
  inline bool has_fetchreq() const;
  inline void clear_fetchreq();
  static const int kFetchReqFieldNumber = 1;
  inline const ::CSDecorateBagFetchReq& fetchreq() const;
  inline ::CSDecorateBagFetchReq* mutable_fetchreq();
  inline ::CSDecorateBagFetchReq* release_fetchreq();
  inline void set_allocated_fetchreq(::CSDecorateBagFetchReq* fetchreq);

  // optional .CSDecorateBagShowSetReq ShowSetReq = 2;
  inline bool has_showsetreq() const;
  inline void clear_showsetreq();
  static const int kShowSetReqFieldNumber = 2;
  inline const ::CSDecorateBagShowSetReq& showsetreq() const;
  inline ::CSDecorateBagShowSetReq* mutable_showsetreq();
  inline ::CSDecorateBagShowSetReq* release_showsetreq();
  inline void set_allocated_showsetreq(::CSDecorateBagShowSetReq* showsetreq);

  // optional .CSDecorateBagVIPFetchReq VIPFetchReq = 3;
  inline bool has_vipfetchreq() const;
  inline void clear_vipfetchreq();
  static const int kVIPFetchReqFieldNumber = 3;
  inline const ::CSDecorateBagVIPFetchReq& vipfetchreq() const;
  inline ::CSDecorateBagVIPFetchReq* mutable_vipfetchreq();
  inline ::CSDecorateBagVIPFetchReq* release_vipfetchreq();
  inline void set_allocated_vipfetchreq(::CSDecorateBagVIPFetchReq* vipfetchreq);

  // @@protoc_insertion_point(class_scope:CSDecorateBagReqParam)
 private:
  inline void set_has_fetchreq();
  inline void clear_has_fetchreq();
  inline void set_has_showsetreq();
  inline void clear_has_showsetreq();
  inline void set_has_vipfetchreq();
  inline void clear_has_vipfetchreq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSDecorateBagFetchReq* fetchreq_;
  ::CSDecorateBagShowSetReq* showsetreq_;
  ::CSDecorateBagVIPFetchReq* vipfetchreq_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSDecorateBagReqParam* default_instance_;
};
// -------------------------------------------------------------------

class CSDecorateBagRspParam : public ::google::protobuf::Message {
 public:
  CSDecorateBagRspParam();
  virtual ~CSDecorateBagRspParam();

  CSDecorateBagRspParam(const CSDecorateBagRspParam& from);

  inline CSDecorateBagRspParam& operator=(const CSDecorateBagRspParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSDecorateBagRspParam& default_instance();

  void Swap(CSDecorateBagRspParam* other);

  // implements Message ----------------------------------------------

  CSDecorateBagRspParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSDecorateBagRspParam& from);
  void MergeFrom(const CSDecorateBagRspParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CSDecorateBagFetchRsp FetchRsp = 1;
  inline bool has_fetchrsp() const;
  inline void clear_fetchrsp();
  static const int kFetchRspFieldNumber = 1;
  inline const ::CSDecorateBagFetchRsp& fetchrsp() const;
  inline ::CSDecorateBagFetchRsp* mutable_fetchrsp();
  inline ::CSDecorateBagFetchRsp* release_fetchrsp();
  inline void set_allocated_fetchrsp(::CSDecorateBagFetchRsp* fetchrsp);

  // optional .CSDecorateBagVIPFetchRsp VIPFetchRsp = 2;
  inline bool has_vipfetchrsp() const;
  inline void clear_vipfetchrsp();
  static const int kVIPFetchRspFieldNumber = 2;
  inline const ::CSDecorateBagVIPFetchRsp& vipfetchrsp() const;
  inline ::CSDecorateBagVIPFetchRsp* mutable_vipfetchrsp();
  inline ::CSDecorateBagVIPFetchRsp* release_vipfetchrsp();
  inline void set_allocated_vipfetchrsp(::CSDecorateBagVIPFetchRsp* vipfetchrsp);

  // @@protoc_insertion_point(class_scope:CSDecorateBagRspParam)
 private:
  inline void set_has_fetchrsp();
  inline void clear_has_fetchrsp();
  inline void set_has_vipfetchrsp();
  inline void clear_has_vipfetchrsp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSDecorateBagFetchRsp* fetchrsp_;
  ::CSDecorateBagVIPFetchRsp* vipfetchrsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSDecorateBagRspParam* default_instance_;
};
// -------------------------------------------------------------------

class CSDecorateBagReq : public ::google::protobuf::Message {
 public:
  CSDecorateBagReq();
  virtual ~CSDecorateBagReq();

  CSDecorateBagReq(const CSDecorateBagReq& from);

  inline CSDecorateBagReq& operator=(const CSDecorateBagReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSDecorateBagReq& default_instance();

  void Swap(CSDecorateBagReq* other);

  // implements Message ----------------------------------------------

  CSDecorateBagReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSDecorateBagReq& from);
  void MergeFrom(const CSDecorateBagReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CSDecorateBagCmd cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::CSDecorateBagCmd cmd() const;
  inline void set_cmd(::CSDecorateBagCmd value);

  // optional .CSDecorateBagReqParam reqParam = 2;
  inline bool has_reqparam() const;
  inline void clear_reqparam();
  static const int kReqParamFieldNumber = 2;
  inline const ::CSDecorateBagReqParam& reqparam() const;
  inline ::CSDecorateBagReqParam* mutable_reqparam();
  inline ::CSDecorateBagReqParam* release_reqparam();
  inline void set_allocated_reqparam(::CSDecorateBagReqParam* reqparam);

  // @@protoc_insertion_point(class_scope:CSDecorateBagReq)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_reqparam();
  inline void clear_has_reqparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSDecorateBagReqParam* reqparam_;
  int cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSDecorateBagReq* default_instance_;
};
// -------------------------------------------------------------------

class CSDecorateBagRsp : public ::google::protobuf::Message {
 public:
  CSDecorateBagRsp();
  virtual ~CSDecorateBagRsp();

  CSDecorateBagRsp(const CSDecorateBagRsp& from);

  inline CSDecorateBagRsp& operator=(const CSDecorateBagRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSDecorateBagRsp& default_instance();

  void Swap(CSDecorateBagRsp* other);

  // implements Message ----------------------------------------------

  CSDecorateBagRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSDecorateBagRsp& from);
  void MergeFrom(const CSDecorateBagRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required .CSDecorateBagCmd cmd = 2;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 2;
  inline ::CSDecorateBagCmd cmd() const;
  inline void set_cmd(::CSDecorateBagCmd value);

  // optional .CSDecorateBagRspParam rspParam = 3;
  inline bool has_rspparam() const;
  inline void clear_rspparam();
  static const int kRspParamFieldNumber = 3;
  inline const ::CSDecorateBagRspParam& rspparam() const;
  inline ::CSDecorateBagRspParam* mutable_rspparam();
  inline ::CSDecorateBagRspParam* release_rspparam();
  inline void set_allocated_rspparam(::CSDecorateBagRspParam* rspparam);

  // @@protoc_insertion_point(class_scope:CSDecorateBagRsp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_rspparam();
  inline void clear_has_rspparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;
  int cmd_;
  ::CSDecorateBagRspParam* rspparam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSDecorateBagRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSMsgBody : public ::google::protobuf::Message {
 public:
  CSMsgBody();
  virtual ~CSMsgBody();

  CSMsgBody(const CSMsgBody& from);

  inline CSMsgBody& operator=(const CSMsgBody& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSMsgBody& default_instance();

  void Swap(CSMsgBody* other);

  // implements Message ----------------------------------------------

  CSMsgBody* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSMsgBody& from);
  void MergeFrom(const CSMsgBody& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CSRegisterLoginReq RegisterLoginReq = 1;
  inline bool has_registerloginreq() const;
  inline void clear_registerloginreq();
  static const int kRegisterLoginReqFieldNumber = 1;
  inline const ::CSRegisterLoginReq& registerloginreq() const;
  inline ::CSRegisterLoginReq* mutable_registerloginreq();
  inline ::CSRegisterLoginReq* release_registerloginreq();
  inline void set_allocated_registerloginreq(::CSRegisterLoginReq* registerloginreq);

  // optional .CSRegisterLoginRsp RegisterLoginRsp = 2;
  inline bool has_registerloginrsp() const;
  inline void clear_registerloginrsp();
  static const int kRegisterLoginRspFieldNumber = 2;
  inline const ::CSRegisterLoginRsp& registerloginrsp() const;
  inline ::CSRegisterLoginRsp* mutable_registerloginrsp();
  inline ::CSRegisterLoginRsp* release_registerloginrsp();
  inline void set_allocated_registerloginrsp(::CSRegisterLoginRsp* registerloginrsp);

  // optional .CSBagReq BagReq = 3;
  inline bool has_bagreq() const;
  inline void clear_bagreq();
  static const int kBagReqFieldNumber = 3;
  inline const ::CSBagReq& bagreq() const;
  inline ::CSBagReq* mutable_bagreq();
  inline ::CSBagReq* release_bagreq();
  inline void set_allocated_bagreq(::CSBagReq* bagreq);

  // optional .CSBagRsp BagRsp = 4;
  inline bool has_bagrsp() const;
  inline void clear_bagrsp();
  static const int kBagRspFieldNumber = 4;
  inline const ::CSBagRsp& bagrsp() const;
  inline ::CSBagRsp* mutable_bagrsp();
  inline ::CSBagRsp* release_bagrsp();
  inline void set_allocated_bagrsp(::CSBagRsp* bagrsp);

  // optional .CSDecorateBagReq DecorateBagReq = 5;
  inline bool has_decoratebagreq() const;
  inline void clear_decoratebagreq();
  static const int kDecorateBagReqFieldNumber = 5;
  inline const ::CSDecorateBagReq& decoratebagreq() const;
  inline ::CSDecorateBagReq* mutable_decoratebagreq();
  inline ::CSDecorateBagReq* release_decoratebagreq();
  inline void set_allocated_decoratebagreq(::CSDecorateBagReq* decoratebagreq);

  // optional .CSDecorateBagRsp DecorateBagRsp = 6;
  inline bool has_decoratebagrsp() const;
  inline void clear_decoratebagrsp();
  static const int kDecorateBagRspFieldNumber = 6;
  inline const ::CSDecorateBagRsp& decoratebagrsp() const;
  inline ::CSDecorateBagRsp* mutable_decoratebagrsp();
  inline ::CSDecorateBagRsp* release_decoratebagrsp();
  inline void set_allocated_decoratebagrsp(::CSDecorateBagRsp* decoratebagrsp);

  // @@protoc_insertion_point(class_scope:CSMsgBody)
 private:
  inline void set_has_registerloginreq();
  inline void clear_has_registerloginreq();
  inline void set_has_registerloginrsp();
  inline void clear_has_registerloginrsp();
  inline void set_has_bagreq();
  inline void clear_has_bagreq();
  inline void set_has_bagrsp();
  inline void clear_has_bagrsp();
  inline void set_has_decoratebagreq();
  inline void clear_has_decoratebagreq();
  inline void set_has_decoratebagrsp();
  inline void clear_has_decoratebagrsp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSRegisterLoginReq* registerloginreq_;
  ::CSRegisterLoginRsp* registerloginrsp_;
  ::CSBagReq* bagreq_;
  ::CSBagRsp* bagrsp_;
  ::CSDecorateBagReq* decoratebagreq_;
  ::CSDecorateBagRsp* decoratebagrsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSMsgBody* default_instance_;
};
// -------------------------------------------------------------------

class CSMsgHead : public ::google::protobuf::Message {
 public:
  CSMsgHead();
  virtual ~CSMsgHead();

  CSMsgHead(const CSMsgHead& from);

  inline CSMsgHead& operator=(const CSMsgHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSMsgHead& default_instance();

  void Swap(CSMsgHead* other);

  // implements Message ----------------------------------------------

  CSMsgHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSMsgHead& from);
  void MergeFrom(const CSMsgHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required .CSMsgID msgID = 2;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 2;
  inline ::CSMsgID msgid() const;
  inline void set_msgid(::CSMsgID value);

  // @@protoc_insertion_point(class_scope:CSMsgHead)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_msgid();
  inline void clear_has_msgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  int msgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSMsgHead* default_instance_;
};
// -------------------------------------------------------------------

class CSMsg : public ::google::protobuf::Message {
 public:
  CSMsg();
  virtual ~CSMsg();

  CSMsg(const CSMsg& from);

  inline CSMsg& operator=(const CSMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSMsg& default_instance();

  void Swap(CSMsg* other);

  // implements Message ----------------------------------------------

  CSMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSMsg& from);
  void MergeFrom(const CSMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CSMsgHead head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::CSMsgHead& head() const;
  inline ::CSMsgHead* mutable_head();
  inline ::CSMsgHead* release_head();
  inline void set_allocated_head(::CSMsgHead* head);

  // required .CSMsgBody body = 2;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::CSMsgBody& body() const;
  inline ::CSMsgBody* mutable_body();
  inline ::CSMsgBody* release_body();
  inline void set_allocated_body(::CSMsgBody* body);

  // @@protoc_insertion_point(class_scope:CSMsg)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_body();
  inline void clear_has_body();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CSMsgHead* head_;
  ::CSMsgBody* body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CSmsg_2eproto();
  friend void protobuf_AssignDesc_CSmsg_2eproto();
  friend void protobuf_ShutdownFile_CSmsg_2eproto();

  void InitAsDefaultInstance();
  static CSMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// CSLoginReq

// optional string account = 1;
inline bool CSLoginReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSLoginReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSLoginReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSLoginReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& CSLoginReq::account() const {
  return *account_;
}
inline void CSLoginReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CSLoginReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CSLoginReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLoginReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* CSLoginReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSLoginReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool CSLoginReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSLoginReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSLoginReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSLoginReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CSLoginReq::password() const {
  return *password_;
}
inline void CSLoginReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CSLoginReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CSLoginReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLoginReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* CSLoginReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSLoginReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSLoginRsp

// optional uint32 type = 1;
inline bool CSLoginRsp::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSLoginRsp::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSLoginRsp::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSLoginRsp::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSLoginRsp::type() const {
  return type_;
}
inline void CSLoginRsp::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional .DBRoleInfo Role = 2;
inline bool CSLoginRsp::has_role() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSLoginRsp::set_has_role() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSLoginRsp::clear_has_role() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSLoginRsp::clear_role() {
  if (role_ != NULL) role_->::DBRoleInfo::Clear();
  clear_has_role();
}
inline const ::DBRoleInfo& CSLoginRsp::role() const {
  return role_ != NULL ? *role_ : *default_instance_->role_;
}
inline ::DBRoleInfo* CSLoginRsp::mutable_role() {
  set_has_role();
  if (role_ == NULL) role_ = new ::DBRoleInfo;
  return role_;
}
inline ::DBRoleInfo* CSLoginRsp::release_role() {
  clear_has_role();
  ::DBRoleInfo* temp = role_;
  role_ = NULL;
  return temp;
}
inline void CSLoginRsp::set_allocated_role(::DBRoleInfo* role) {
  delete role_;
  role_ = role;
  if (role) {
    set_has_role();
  } else {
    clear_has_role();
  }
}

// -------------------------------------------------------------------

// CSRegisterReq

// optional string account = 1;
inline bool CSRegisterReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegisterReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegisterReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegisterReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& CSRegisterReq::account() const {
  return *account_;
}
inline void CSRegisterReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CSRegisterReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CSRegisterReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRegisterReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* CSRegisterReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSRegisterReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool CSRegisterReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRegisterReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRegisterReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRegisterReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CSRegisterReq::password() const {
  return *password_;
}
inline void CSRegisterReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CSRegisterReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CSRegisterReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRegisterReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* CSRegisterReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSRegisterReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool CSRegisterReq::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSRegisterReq::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSRegisterReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSRegisterReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSRegisterReq::name() const {
  return *name_;
}
inline void CSRegisterReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSRegisterReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSRegisterReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRegisterReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CSRegisterReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSRegisterReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSRegisterRsp

// optional uint32 type = 1;
inline bool CSRegisterRsp::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegisterRsp::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegisterRsp::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegisterRsp::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSRegisterRsp::type() const {
  return type_;
}
inline void CSRegisterRsp::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// CSQuitReq

// optional uint32 pad = 1;
inline bool CSQuitReq::has_pad() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQuitReq::set_has_pad() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQuitReq::clear_has_pad() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQuitReq::clear_pad() {
  pad_ = 0u;
  clear_has_pad();
}
inline ::google::protobuf::uint32 CSQuitReq::pad() const {
  return pad_;
}
inline void CSQuitReq::set_pad(::google::protobuf::uint32 value) {
  set_has_pad();
  pad_ = value;
}

// -------------------------------------------------------------------

// CSRegisterLoginReqParam

// optional .CSLoginReq LoginReq = 1;
inline bool CSRegisterLoginReqParam::has_loginreq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegisterLoginReqParam::set_has_loginreq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegisterLoginReqParam::clear_has_loginreq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegisterLoginReqParam::clear_loginreq() {
  if (loginreq_ != NULL) loginreq_->::CSLoginReq::Clear();
  clear_has_loginreq();
}
inline const ::CSLoginReq& CSRegisterLoginReqParam::loginreq() const {
  return loginreq_ != NULL ? *loginreq_ : *default_instance_->loginreq_;
}
inline ::CSLoginReq* CSRegisterLoginReqParam::mutable_loginreq() {
  set_has_loginreq();
  if (loginreq_ == NULL) loginreq_ = new ::CSLoginReq;
  return loginreq_;
}
inline ::CSLoginReq* CSRegisterLoginReqParam::release_loginreq() {
  clear_has_loginreq();
  ::CSLoginReq* temp = loginreq_;
  loginreq_ = NULL;
  return temp;
}
inline void CSRegisterLoginReqParam::set_allocated_loginreq(::CSLoginReq* loginreq) {
  delete loginreq_;
  loginreq_ = loginreq;
  if (loginreq) {
    set_has_loginreq();
  } else {
    clear_has_loginreq();
  }
}

// optional .CSRegisterReq RegisterReq = 2;
inline bool CSRegisterLoginReqParam::has_registerreq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRegisterLoginReqParam::set_has_registerreq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRegisterLoginReqParam::clear_has_registerreq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRegisterLoginReqParam::clear_registerreq() {
  if (registerreq_ != NULL) registerreq_->::CSRegisterReq::Clear();
  clear_has_registerreq();
}
inline const ::CSRegisterReq& CSRegisterLoginReqParam::registerreq() const {
  return registerreq_ != NULL ? *registerreq_ : *default_instance_->registerreq_;
}
inline ::CSRegisterReq* CSRegisterLoginReqParam::mutable_registerreq() {
  set_has_registerreq();
  if (registerreq_ == NULL) registerreq_ = new ::CSRegisterReq;
  return registerreq_;
}
inline ::CSRegisterReq* CSRegisterLoginReqParam::release_registerreq() {
  clear_has_registerreq();
  ::CSRegisterReq* temp = registerreq_;
  registerreq_ = NULL;
  return temp;
}
inline void CSRegisterLoginReqParam::set_allocated_registerreq(::CSRegisterReq* registerreq) {
  delete registerreq_;
  registerreq_ = registerreq;
  if (registerreq) {
    set_has_registerreq();
  } else {
    clear_has_registerreq();
  }
}

// optional .CSQuitReq QuitReq = 3;
inline bool CSRegisterLoginReqParam::has_quitreq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSRegisterLoginReqParam::set_has_quitreq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSRegisterLoginReqParam::clear_has_quitreq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSRegisterLoginReqParam::clear_quitreq() {
  if (quitreq_ != NULL) quitreq_->::CSQuitReq::Clear();
  clear_has_quitreq();
}
inline const ::CSQuitReq& CSRegisterLoginReqParam::quitreq() const {
  return quitreq_ != NULL ? *quitreq_ : *default_instance_->quitreq_;
}
inline ::CSQuitReq* CSRegisterLoginReqParam::mutable_quitreq() {
  set_has_quitreq();
  if (quitreq_ == NULL) quitreq_ = new ::CSQuitReq;
  return quitreq_;
}
inline ::CSQuitReq* CSRegisterLoginReqParam::release_quitreq() {
  clear_has_quitreq();
  ::CSQuitReq* temp = quitreq_;
  quitreq_ = NULL;
  return temp;
}
inline void CSRegisterLoginReqParam::set_allocated_quitreq(::CSQuitReq* quitreq) {
  delete quitreq_;
  quitreq_ = quitreq;
  if (quitreq) {
    set_has_quitreq();
  } else {
    clear_has_quitreq();
  }
}

// -------------------------------------------------------------------

// CSRegisterLoginRspParam

// optional .CSLoginRsp LoginRsp = 1;
inline bool CSRegisterLoginRspParam::has_loginrsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegisterLoginRspParam::set_has_loginrsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegisterLoginRspParam::clear_has_loginrsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegisterLoginRspParam::clear_loginrsp() {
  if (loginrsp_ != NULL) loginrsp_->::CSLoginRsp::Clear();
  clear_has_loginrsp();
}
inline const ::CSLoginRsp& CSRegisterLoginRspParam::loginrsp() const {
  return loginrsp_ != NULL ? *loginrsp_ : *default_instance_->loginrsp_;
}
inline ::CSLoginRsp* CSRegisterLoginRspParam::mutable_loginrsp() {
  set_has_loginrsp();
  if (loginrsp_ == NULL) loginrsp_ = new ::CSLoginRsp;
  return loginrsp_;
}
inline ::CSLoginRsp* CSRegisterLoginRspParam::release_loginrsp() {
  clear_has_loginrsp();
  ::CSLoginRsp* temp = loginrsp_;
  loginrsp_ = NULL;
  return temp;
}
inline void CSRegisterLoginRspParam::set_allocated_loginrsp(::CSLoginRsp* loginrsp) {
  delete loginrsp_;
  loginrsp_ = loginrsp;
  if (loginrsp) {
    set_has_loginrsp();
  } else {
    clear_has_loginrsp();
  }
}

// optional .CSRegisterRsp RegisterRsp = 2;
inline bool CSRegisterLoginRspParam::has_registerrsp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRegisterLoginRspParam::set_has_registerrsp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRegisterLoginRspParam::clear_has_registerrsp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRegisterLoginRspParam::clear_registerrsp() {
  if (registerrsp_ != NULL) registerrsp_->::CSRegisterRsp::Clear();
  clear_has_registerrsp();
}
inline const ::CSRegisterRsp& CSRegisterLoginRspParam::registerrsp() const {
  return registerrsp_ != NULL ? *registerrsp_ : *default_instance_->registerrsp_;
}
inline ::CSRegisterRsp* CSRegisterLoginRspParam::mutable_registerrsp() {
  set_has_registerrsp();
  if (registerrsp_ == NULL) registerrsp_ = new ::CSRegisterRsp;
  return registerrsp_;
}
inline ::CSRegisterRsp* CSRegisterLoginRspParam::release_registerrsp() {
  clear_has_registerrsp();
  ::CSRegisterRsp* temp = registerrsp_;
  registerrsp_ = NULL;
  return temp;
}
inline void CSRegisterLoginRspParam::set_allocated_registerrsp(::CSRegisterRsp* registerrsp) {
  delete registerrsp_;
  registerrsp_ = registerrsp;
  if (registerrsp) {
    set_has_registerrsp();
  } else {
    clear_has_registerrsp();
  }
}

// -------------------------------------------------------------------

// CSRegisterLoginReq

// required .CSRegisterLoginCmd cmd = 1;
inline bool CSRegisterLoginReq::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegisterLoginReq::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegisterLoginReq::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegisterLoginReq::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::CSRegisterLoginCmd CSRegisterLoginReq::cmd() const {
  return static_cast< ::CSRegisterLoginCmd >(cmd_);
}
inline void CSRegisterLoginReq::set_cmd(::CSRegisterLoginCmd value) {
  assert(::CSRegisterLoginCmd_IsValid(value));
  set_has_cmd();
  cmd_ = value;
}

// optional .CSRegisterLoginReqParam reqParam = 2;
inline bool CSRegisterLoginReq::has_reqparam() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRegisterLoginReq::set_has_reqparam() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRegisterLoginReq::clear_has_reqparam() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRegisterLoginReq::clear_reqparam() {
  if (reqparam_ != NULL) reqparam_->::CSRegisterLoginReqParam::Clear();
  clear_has_reqparam();
}
inline const ::CSRegisterLoginReqParam& CSRegisterLoginReq::reqparam() const {
  return reqparam_ != NULL ? *reqparam_ : *default_instance_->reqparam_;
}
inline ::CSRegisterLoginReqParam* CSRegisterLoginReq::mutable_reqparam() {
  set_has_reqparam();
  if (reqparam_ == NULL) reqparam_ = new ::CSRegisterLoginReqParam;
  return reqparam_;
}
inline ::CSRegisterLoginReqParam* CSRegisterLoginReq::release_reqparam() {
  clear_has_reqparam();
  ::CSRegisterLoginReqParam* temp = reqparam_;
  reqparam_ = NULL;
  return temp;
}
inline void CSRegisterLoginReq::set_allocated_reqparam(::CSRegisterLoginReqParam* reqparam) {
  delete reqparam_;
  reqparam_ = reqparam;
  if (reqparam) {
    set_has_reqparam();
  } else {
    clear_has_reqparam();
  }
}

// -------------------------------------------------------------------

// CSRegisterLoginRsp

// optional int32 result = 1;
inline bool CSRegisterLoginRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegisterLoginRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegisterLoginRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegisterLoginRsp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CSRegisterLoginRsp::result() const {
  return result_;
}
inline void CSRegisterLoginRsp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required .CSRegisterLoginCmd cmd = 2;
inline bool CSRegisterLoginRsp::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRegisterLoginRsp::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRegisterLoginRsp::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRegisterLoginRsp::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::CSRegisterLoginCmd CSRegisterLoginRsp::cmd() const {
  return static_cast< ::CSRegisterLoginCmd >(cmd_);
}
inline void CSRegisterLoginRsp::set_cmd(::CSRegisterLoginCmd value) {
  assert(::CSRegisterLoginCmd_IsValid(value));
  set_has_cmd();
  cmd_ = value;
}

// optional .CSRegisterLoginRspParam rspParam = 3;
inline bool CSRegisterLoginRsp::has_rspparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSRegisterLoginRsp::set_has_rspparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSRegisterLoginRsp::clear_has_rspparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSRegisterLoginRsp::clear_rspparam() {
  if (rspparam_ != NULL) rspparam_->::CSRegisterLoginRspParam::Clear();
  clear_has_rspparam();
}
inline const ::CSRegisterLoginRspParam& CSRegisterLoginRsp::rspparam() const {
  return rspparam_ != NULL ? *rspparam_ : *default_instance_->rspparam_;
}
inline ::CSRegisterLoginRspParam* CSRegisterLoginRsp::mutable_rspparam() {
  set_has_rspparam();
  if (rspparam_ == NULL) rspparam_ = new ::CSRegisterLoginRspParam;
  return rspparam_;
}
inline ::CSRegisterLoginRspParam* CSRegisterLoginRsp::release_rspparam() {
  clear_has_rspparam();
  ::CSRegisterLoginRspParam* temp = rspparam_;
  rspparam_ = NULL;
  return temp;
}
inline void CSRegisterLoginRsp::set_allocated_rspparam(::CSRegisterLoginRspParam* rspparam) {
  delete rspparam_;
  rspparam_ = rspparam;
  if (rspparam) {
    set_has_rspparam();
  } else {
    clear_has_rspparam();
  }
}

// -------------------------------------------------------------------

// CSBagFetchReq

// optional uint32 pad = 1;
inline bool CSBagFetchReq::has_pad() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagFetchReq::set_has_pad() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagFetchReq::clear_has_pad() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagFetchReq::clear_pad() {
  pad_ = 0u;
  clear_has_pad();
}
inline ::google::protobuf::uint32 CSBagFetchReq::pad() const {
  return pad_;
}
inline void CSBagFetchReq::set_pad(::google::protobuf::uint32 value) {
  set_has_pad();
  pad_ = value;
}

// -------------------------------------------------------------------

// CSBagGridInfo

// optional uint32 ItemId = 1;
inline bool CSBagGridInfo::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagGridInfo::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagGridInfo::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagGridInfo::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 CSBagGridInfo::itemid() const {
  return itemid_;
}
inline void CSBagGridInfo::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional uint32 Num = 2;
inline bool CSBagGridInfo::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBagGridInfo::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBagGridInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBagGridInfo::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 CSBagGridInfo::num() const {
  return num_;
}
inline void CSBagGridInfo::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// CSBagBagInfo

// repeated .CSBagGridInfo GridInfo = 1;
inline int CSBagBagInfo::gridinfo_size() const {
  return gridinfo_.size();
}
inline void CSBagBagInfo::clear_gridinfo() {
  gridinfo_.Clear();
}
inline const ::CSBagGridInfo& CSBagBagInfo::gridinfo(int index) const {
  return gridinfo_.Get(index);
}
inline ::CSBagGridInfo* CSBagBagInfo::mutable_gridinfo(int index) {
  return gridinfo_.Mutable(index);
}
inline ::CSBagGridInfo* CSBagBagInfo::add_gridinfo() {
  return gridinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CSBagGridInfo >&
CSBagBagInfo::gridinfo() const {
  return gridinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::CSBagGridInfo >*
CSBagBagInfo::mutable_gridinfo() {
  return &gridinfo_;
}

// -------------------------------------------------------------------

// CSBagFetchRsp

// optional .CSBagBagInfo BagInfo = 1;
inline bool CSBagFetchRsp::has_baginfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagFetchRsp::set_has_baginfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagFetchRsp::clear_has_baginfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagFetchRsp::clear_baginfo() {
  if (baginfo_ != NULL) baginfo_->::CSBagBagInfo::Clear();
  clear_has_baginfo();
}
inline const ::CSBagBagInfo& CSBagFetchRsp::baginfo() const {
  return baginfo_ != NULL ? *baginfo_ : *default_instance_->baginfo_;
}
inline ::CSBagBagInfo* CSBagFetchRsp::mutable_baginfo() {
  set_has_baginfo();
  if (baginfo_ == NULL) baginfo_ = new ::CSBagBagInfo;
  return baginfo_;
}
inline ::CSBagBagInfo* CSBagFetchRsp::release_baginfo() {
  clear_has_baginfo();
  ::CSBagBagInfo* temp = baginfo_;
  baginfo_ = NULL;
  return temp;
}
inline void CSBagFetchRsp::set_allocated_baginfo(::CSBagBagInfo* baginfo) {
  delete baginfo_;
  baginfo_ = baginfo;
  if (baginfo) {
    set_has_baginfo();
  } else {
    clear_has_baginfo();
  }
}

// -------------------------------------------------------------------

// CSBagUseReq

// optional uint32 ItemId = 1;
inline bool CSBagUseReq::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagUseReq::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagUseReq::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagUseReq::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 CSBagUseReq::itemid() const {
  return itemid_;
}
inline void CSBagUseReq::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional uint32 ItemNum = 2;
inline bool CSBagUseReq::has_itemnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBagUseReq::set_has_itemnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBagUseReq::clear_has_itemnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBagUseReq::clear_itemnum() {
  itemnum_ = 0u;
  clear_has_itemnum();
}
inline ::google::protobuf::uint32 CSBagUseReq::itemnum() const {
  return itemnum_;
}
inline void CSBagUseReq::set_itemnum(::google::protobuf::uint32 value) {
  set_has_itemnum();
  itemnum_ = value;
}

// optional uint32 PickedId = 3;
inline bool CSBagUseReq::has_pickedid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBagUseReq::set_has_pickedid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBagUseReq::clear_has_pickedid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBagUseReq::clear_pickedid() {
  pickedid_ = 0u;
  clear_has_pickedid();
}
inline ::google::protobuf::uint32 CSBagUseReq::pickedid() const {
  return pickedid_;
}
inline void CSBagUseReq::set_pickedid(::google::protobuf::uint32 value) {
  set_has_pickedid();
  pickedid_ = value;
}

// -------------------------------------------------------------------

// CSItemInfo

// optional int32 ID = 1;
inline bool CSItemInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSItemInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSItemInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSItemInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 CSItemInfo::id() const {
  return id_;
}
inline void CSItemInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 num = 2;
inline bool CSItemInfo::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSItemInfo::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSItemInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSItemInfo::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 CSItemInfo::num() const {
  return num_;
}
inline void CSItemInfo::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// CSItemInfoList

// repeated .CSItemInfo ItemInfo = 1;
inline int CSItemInfoList::iteminfo_size() const {
  return iteminfo_.size();
}
inline void CSItemInfoList::clear_iteminfo() {
  iteminfo_.Clear();
}
inline const ::CSItemInfo& CSItemInfoList::iteminfo(int index) const {
  return iteminfo_.Get(index);
}
inline ::CSItemInfo* CSItemInfoList::mutable_iteminfo(int index) {
  return iteminfo_.Mutable(index);
}
inline ::CSItemInfo* CSItemInfoList::add_iteminfo() {
  return iteminfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CSItemInfo >&
CSItemInfoList::iteminfo() const {
  return iteminfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::CSItemInfo >*
CSItemInfoList::mutable_iteminfo() {
  return &iteminfo_;
}

// -------------------------------------------------------------------

// CSBagUseRsp

// optional .CSItemInfoList ItemInfoList = 1;
inline bool CSBagUseRsp::has_iteminfolist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagUseRsp::set_has_iteminfolist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagUseRsp::clear_has_iteminfolist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagUseRsp::clear_iteminfolist() {
  if (iteminfolist_ != NULL) iteminfolist_->::CSItemInfoList::Clear();
  clear_has_iteminfolist();
}
inline const ::CSItemInfoList& CSBagUseRsp::iteminfolist() const {
  return iteminfolist_ != NULL ? *iteminfolist_ : *default_instance_->iteminfolist_;
}
inline ::CSItemInfoList* CSBagUseRsp::mutable_iteminfolist() {
  set_has_iteminfolist();
  if (iteminfolist_ == NULL) iteminfolist_ = new ::CSItemInfoList;
  return iteminfolist_;
}
inline ::CSItemInfoList* CSBagUseRsp::release_iteminfolist() {
  clear_has_iteminfolist();
  ::CSItemInfoList* temp = iteminfolist_;
  iteminfolist_ = NULL;
  return temp;
}
inline void CSBagUseRsp::set_allocated_iteminfolist(::CSItemInfoList* iteminfolist) {
  delete iteminfolist_;
  iteminfolist_ = iteminfolist;
  if (iteminfolist) {
    set_has_iteminfolist();
  } else {
    clear_has_iteminfolist();
  }
}

// -------------------------------------------------------------------

// CSBagReqParam

// optional .CSBagFetchReq FetchReq = 1;
inline bool CSBagReqParam::has_fetchreq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagReqParam::set_has_fetchreq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagReqParam::clear_has_fetchreq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagReqParam::clear_fetchreq() {
  if (fetchreq_ != NULL) fetchreq_->::CSBagFetchReq::Clear();
  clear_has_fetchreq();
}
inline const ::CSBagFetchReq& CSBagReqParam::fetchreq() const {
  return fetchreq_ != NULL ? *fetchreq_ : *default_instance_->fetchreq_;
}
inline ::CSBagFetchReq* CSBagReqParam::mutable_fetchreq() {
  set_has_fetchreq();
  if (fetchreq_ == NULL) fetchreq_ = new ::CSBagFetchReq;
  return fetchreq_;
}
inline ::CSBagFetchReq* CSBagReqParam::release_fetchreq() {
  clear_has_fetchreq();
  ::CSBagFetchReq* temp = fetchreq_;
  fetchreq_ = NULL;
  return temp;
}
inline void CSBagReqParam::set_allocated_fetchreq(::CSBagFetchReq* fetchreq) {
  delete fetchreq_;
  fetchreq_ = fetchreq;
  if (fetchreq) {
    set_has_fetchreq();
  } else {
    clear_has_fetchreq();
  }
}

// optional .CSBagUseReq UseReq = 2;
inline bool CSBagReqParam::has_usereq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBagReqParam::set_has_usereq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBagReqParam::clear_has_usereq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBagReqParam::clear_usereq() {
  if (usereq_ != NULL) usereq_->::CSBagUseReq::Clear();
  clear_has_usereq();
}
inline const ::CSBagUseReq& CSBagReqParam::usereq() const {
  return usereq_ != NULL ? *usereq_ : *default_instance_->usereq_;
}
inline ::CSBagUseReq* CSBagReqParam::mutable_usereq() {
  set_has_usereq();
  if (usereq_ == NULL) usereq_ = new ::CSBagUseReq;
  return usereq_;
}
inline ::CSBagUseReq* CSBagReqParam::release_usereq() {
  clear_has_usereq();
  ::CSBagUseReq* temp = usereq_;
  usereq_ = NULL;
  return temp;
}
inline void CSBagReqParam::set_allocated_usereq(::CSBagUseReq* usereq) {
  delete usereq_;
  usereq_ = usereq;
  if (usereq) {
    set_has_usereq();
  } else {
    clear_has_usereq();
  }
}

// -------------------------------------------------------------------

// CSBagRspParam

// optional .CSBagFetchRsp FetchRsp = 1;
inline bool CSBagRspParam::has_fetchrsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagRspParam::set_has_fetchrsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagRspParam::clear_has_fetchrsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagRspParam::clear_fetchrsp() {
  if (fetchrsp_ != NULL) fetchrsp_->::CSBagFetchRsp::Clear();
  clear_has_fetchrsp();
}
inline const ::CSBagFetchRsp& CSBagRspParam::fetchrsp() const {
  return fetchrsp_ != NULL ? *fetchrsp_ : *default_instance_->fetchrsp_;
}
inline ::CSBagFetchRsp* CSBagRspParam::mutable_fetchrsp() {
  set_has_fetchrsp();
  if (fetchrsp_ == NULL) fetchrsp_ = new ::CSBagFetchRsp;
  return fetchrsp_;
}
inline ::CSBagFetchRsp* CSBagRspParam::release_fetchrsp() {
  clear_has_fetchrsp();
  ::CSBagFetchRsp* temp = fetchrsp_;
  fetchrsp_ = NULL;
  return temp;
}
inline void CSBagRspParam::set_allocated_fetchrsp(::CSBagFetchRsp* fetchrsp) {
  delete fetchrsp_;
  fetchrsp_ = fetchrsp;
  if (fetchrsp) {
    set_has_fetchrsp();
  } else {
    clear_has_fetchrsp();
  }
}

// optional .CSBagUseRsp UseRsp = 2;
inline bool CSBagRspParam::has_usersp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBagRspParam::set_has_usersp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBagRspParam::clear_has_usersp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBagRspParam::clear_usersp() {
  if (usersp_ != NULL) usersp_->::CSBagUseRsp::Clear();
  clear_has_usersp();
}
inline const ::CSBagUseRsp& CSBagRspParam::usersp() const {
  return usersp_ != NULL ? *usersp_ : *default_instance_->usersp_;
}
inline ::CSBagUseRsp* CSBagRspParam::mutable_usersp() {
  set_has_usersp();
  if (usersp_ == NULL) usersp_ = new ::CSBagUseRsp;
  return usersp_;
}
inline ::CSBagUseRsp* CSBagRspParam::release_usersp() {
  clear_has_usersp();
  ::CSBagUseRsp* temp = usersp_;
  usersp_ = NULL;
  return temp;
}
inline void CSBagRspParam::set_allocated_usersp(::CSBagUseRsp* usersp) {
  delete usersp_;
  usersp_ = usersp;
  if (usersp) {
    set_has_usersp();
  } else {
    clear_has_usersp();
  }
}

// -------------------------------------------------------------------

// CSBagReq

// required .CSBagCmd cmd = 1;
inline bool CSBagReq::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagReq::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagReq::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagReq::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::CSBagCmd CSBagReq::cmd() const {
  return static_cast< ::CSBagCmd >(cmd_);
}
inline void CSBagReq::set_cmd(::CSBagCmd value) {
  assert(::CSBagCmd_IsValid(value));
  set_has_cmd();
  cmd_ = value;
}

// optional .CSBagReqParam reqParam = 2;
inline bool CSBagReq::has_reqparam() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBagReq::set_has_reqparam() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBagReq::clear_has_reqparam() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBagReq::clear_reqparam() {
  if (reqparam_ != NULL) reqparam_->::CSBagReqParam::Clear();
  clear_has_reqparam();
}
inline const ::CSBagReqParam& CSBagReq::reqparam() const {
  return reqparam_ != NULL ? *reqparam_ : *default_instance_->reqparam_;
}
inline ::CSBagReqParam* CSBagReq::mutable_reqparam() {
  set_has_reqparam();
  if (reqparam_ == NULL) reqparam_ = new ::CSBagReqParam;
  return reqparam_;
}
inline ::CSBagReqParam* CSBagReq::release_reqparam() {
  clear_has_reqparam();
  ::CSBagReqParam* temp = reqparam_;
  reqparam_ = NULL;
  return temp;
}
inline void CSBagReq::set_allocated_reqparam(::CSBagReqParam* reqparam) {
  delete reqparam_;
  reqparam_ = reqparam;
  if (reqparam) {
    set_has_reqparam();
  } else {
    clear_has_reqparam();
  }
}

// -------------------------------------------------------------------

// CSBagRsp

// optional int32 result = 1;
inline bool CSBagRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagRsp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CSBagRsp::result() const {
  return result_;
}
inline void CSBagRsp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required .CSBagCmd cmd = 2;
inline bool CSBagRsp::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBagRsp::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBagRsp::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBagRsp::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::CSBagCmd CSBagRsp::cmd() const {
  return static_cast< ::CSBagCmd >(cmd_);
}
inline void CSBagRsp::set_cmd(::CSBagCmd value) {
  assert(::CSBagCmd_IsValid(value));
  set_has_cmd();
  cmd_ = value;
}

// optional .CSBagRspParam rspParam = 3;
inline bool CSBagRsp::has_rspparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBagRsp::set_has_rspparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBagRsp::clear_has_rspparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBagRsp::clear_rspparam() {
  if (rspparam_ != NULL) rspparam_->::CSBagRspParam::Clear();
  clear_has_rspparam();
}
inline const ::CSBagRspParam& CSBagRsp::rspparam() const {
  return rspparam_ != NULL ? *rspparam_ : *default_instance_->rspparam_;
}
inline ::CSBagRspParam* CSBagRsp::mutable_rspparam() {
  set_has_rspparam();
  if (rspparam_ == NULL) rspparam_ = new ::CSBagRspParam;
  return rspparam_;
}
inline ::CSBagRspParam* CSBagRsp::release_rspparam() {
  clear_has_rspparam();
  ::CSBagRspParam* temp = rspparam_;
  rspparam_ = NULL;
  return temp;
}
inline void CSBagRsp::set_allocated_rspparam(::CSBagRspParam* rspparam) {
  delete rspparam_;
  rspparam_ = rspparam;
  if (rspparam) {
    set_has_rspparam();
  } else {
    clear_has_rspparam();
  }
}

// -------------------------------------------------------------------

// CSDecorateBagFetchReq

// optional uint32 type = 1;
inline bool CSDecorateBagFetchReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDecorateBagFetchReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDecorateBagFetchReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDecorateBagFetchReq::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSDecorateBagFetchReq::type() const {
  return type_;
}
inline void CSDecorateBagFetchReq::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// CSDecorateBagGridInfo

// optional uint32 ItemId = 1;
inline bool CSDecorateBagGridInfo::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDecorateBagGridInfo::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDecorateBagGridInfo::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDecorateBagGridInfo::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 CSDecorateBagGridInfo::itemid() const {
  return itemid_;
}
inline void CSDecorateBagGridInfo::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional uint32 type = 2;
inline bool CSDecorateBagGridInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDecorateBagGridInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDecorateBagGridInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDecorateBagGridInfo::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSDecorateBagGridInfo::type() const {
  return type_;
}
inline void CSDecorateBagGridInfo::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint64 EndTime = 3;
inline bool CSDecorateBagGridInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSDecorateBagGridInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSDecorateBagGridInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSDecorateBagGridInfo::clear_endtime() {
  endtime_ = GOOGLE_ULONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::uint64 CSDecorateBagGridInfo::endtime() const {
  return endtime_;
}
inline void CSDecorateBagGridInfo::set_endtime(::google::protobuf::uint64 value) {
  set_has_endtime();
  endtime_ = value;
}

// -------------------------------------------------------------------

// CSDecorateBagInfo

// repeated .CSDecorateBagGridInfo DecorateGridInfo = 1;
inline int CSDecorateBagInfo::decorategridinfo_size() const {
  return decorategridinfo_.size();
}
inline void CSDecorateBagInfo::clear_decorategridinfo() {
  decorategridinfo_.Clear();
}
inline const ::CSDecorateBagGridInfo& CSDecorateBagInfo::decorategridinfo(int index) const {
  return decorategridinfo_.Get(index);
}
inline ::CSDecorateBagGridInfo* CSDecorateBagInfo::mutable_decorategridinfo(int index) {
  return decorategridinfo_.Mutable(index);
}
inline ::CSDecorateBagGridInfo* CSDecorateBagInfo::add_decorategridinfo() {
  return decorategridinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CSDecorateBagGridInfo >&
CSDecorateBagInfo::decorategridinfo() const {
  return decorategridinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::CSDecorateBagGridInfo >*
CSDecorateBagInfo::mutable_decorategridinfo() {
  return &decorategridinfo_;
}

// -------------------------------------------------------------------

// CSDecorateBagFetchRsp

// optional uint32 type = 1;
inline bool CSDecorateBagFetchRsp::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDecorateBagFetchRsp::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDecorateBagFetchRsp::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDecorateBagFetchRsp::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSDecorateBagFetchRsp::type() const {
  return type_;
}
inline void CSDecorateBagFetchRsp::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 id = 2;
inline bool CSDecorateBagFetchRsp::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDecorateBagFetchRsp::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDecorateBagFetchRsp::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDecorateBagFetchRsp::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSDecorateBagFetchRsp::id() const {
  return id_;
}
inline void CSDecorateBagFetchRsp::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional .CSDecorateBagInfo DecorateBagInfo = 3;
inline bool CSDecorateBagFetchRsp::has_decoratebaginfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSDecorateBagFetchRsp::set_has_decoratebaginfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSDecorateBagFetchRsp::clear_has_decoratebaginfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSDecorateBagFetchRsp::clear_decoratebaginfo() {
  if (decoratebaginfo_ != NULL) decoratebaginfo_->::CSDecorateBagInfo::Clear();
  clear_has_decoratebaginfo();
}
inline const ::CSDecorateBagInfo& CSDecorateBagFetchRsp::decoratebaginfo() const {
  return decoratebaginfo_ != NULL ? *decoratebaginfo_ : *default_instance_->decoratebaginfo_;
}
inline ::CSDecorateBagInfo* CSDecorateBagFetchRsp::mutable_decoratebaginfo() {
  set_has_decoratebaginfo();
  if (decoratebaginfo_ == NULL) decoratebaginfo_ = new ::CSDecorateBagInfo;
  return decoratebaginfo_;
}
inline ::CSDecorateBagInfo* CSDecorateBagFetchRsp::release_decoratebaginfo() {
  clear_has_decoratebaginfo();
  ::CSDecorateBagInfo* temp = decoratebaginfo_;
  decoratebaginfo_ = NULL;
  return temp;
}
inline void CSDecorateBagFetchRsp::set_allocated_decoratebaginfo(::CSDecorateBagInfo* decoratebaginfo) {
  delete decoratebaginfo_;
  decoratebaginfo_ = decoratebaginfo;
  if (decoratebaginfo) {
    set_has_decoratebaginfo();
  } else {
    clear_has_decoratebaginfo();
  }
}

// -------------------------------------------------------------------

// CSDecorateBagShowSetReq

// optional uint32 Type = 1;
inline bool CSDecorateBagShowSetReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDecorateBagShowSetReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDecorateBagShowSetReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDecorateBagShowSetReq::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSDecorateBagShowSetReq::type() const {
  return type_;
}
inline void CSDecorateBagShowSetReq::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 id = 2;
inline bool CSDecorateBagShowSetReq::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDecorateBagShowSetReq::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDecorateBagShowSetReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDecorateBagShowSetReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSDecorateBagShowSetReq::id() const {
  return id_;
}
inline void CSDecorateBagShowSetReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// CSDecorateBagVIPFetchReq

// optional uint32 type = 1;
inline bool CSDecorateBagVIPFetchReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDecorateBagVIPFetchReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDecorateBagVIPFetchReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDecorateBagVIPFetchReq::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSDecorateBagVIPFetchReq::type() const {
  return type_;
}
inline void CSDecorateBagVIPFetchReq::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// CSDecorateBagVIPItem

// optional uint32 VipGread = 1;
inline bool CSDecorateBagVIPItem::has_vipgread() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDecorateBagVIPItem::set_has_vipgread() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDecorateBagVIPItem::clear_has_vipgread() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDecorateBagVIPItem::clear_vipgread() {
  vipgread_ = 0u;
  clear_has_vipgread();
}
inline ::google::protobuf::uint32 CSDecorateBagVIPItem::vipgread() const {
  return vipgread_;
}
inline void CSDecorateBagVIPItem::set_vipgread(::google::protobuf::uint32 value) {
  set_has_vipgread();
  vipgread_ = value;
}

// optional uint32 VipExper = 2;
inline bool CSDecorateBagVIPItem::has_vipexper() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDecorateBagVIPItem::set_has_vipexper() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDecorateBagVIPItem::clear_has_vipexper() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDecorateBagVIPItem::clear_vipexper() {
  vipexper_ = 0u;
  clear_has_vipexper();
}
inline ::google::protobuf::uint32 CSDecorateBagVIPItem::vipexper() const {
  return vipexper_;
}
inline void CSDecorateBagVIPItem::set_vipexper(::google::protobuf::uint32 value) {
  set_has_vipexper();
  vipexper_ = value;
}

// -------------------------------------------------------------------

// CSDecorateBagVIPList

// repeated .CSDecorateBagVIPItem VIPItemList = 1;
inline int CSDecorateBagVIPList::vipitemlist_size() const {
  return vipitemlist_.size();
}
inline void CSDecorateBagVIPList::clear_vipitemlist() {
  vipitemlist_.Clear();
}
inline const ::CSDecorateBagVIPItem& CSDecorateBagVIPList::vipitemlist(int index) const {
  return vipitemlist_.Get(index);
}
inline ::CSDecorateBagVIPItem* CSDecorateBagVIPList::mutable_vipitemlist(int index) {
  return vipitemlist_.Mutable(index);
}
inline ::CSDecorateBagVIPItem* CSDecorateBagVIPList::add_vipitemlist() {
  return vipitemlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CSDecorateBagVIPItem >&
CSDecorateBagVIPList::vipitemlist() const {
  return vipitemlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::CSDecorateBagVIPItem >*
CSDecorateBagVIPList::mutable_vipitemlist() {
  return &vipitemlist_;
}

// -------------------------------------------------------------------

// CSDecorateBagVIPFetchRsp

// optional uint32 type = 1;
inline bool CSDecorateBagVIPFetchRsp::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDecorateBagVIPFetchRsp::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDecorateBagVIPFetchRsp::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDecorateBagVIPFetchRsp::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSDecorateBagVIPFetchRsp::type() const {
  return type_;
}
inline void CSDecorateBagVIPFetchRsp::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 id = 2;
inline bool CSDecorateBagVIPFetchRsp::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDecorateBagVIPFetchRsp::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDecorateBagVIPFetchRsp::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDecorateBagVIPFetchRsp::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSDecorateBagVIPFetchRsp::id() const {
  return id_;
}
inline void CSDecorateBagVIPFetchRsp::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional .CSDecorateBagInfo DecorateBagInfo = 3;
inline bool CSDecorateBagVIPFetchRsp::has_decoratebaginfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSDecorateBagVIPFetchRsp::set_has_decoratebaginfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSDecorateBagVIPFetchRsp::clear_has_decoratebaginfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSDecorateBagVIPFetchRsp::clear_decoratebaginfo() {
  if (decoratebaginfo_ != NULL) decoratebaginfo_->::CSDecorateBagInfo::Clear();
  clear_has_decoratebaginfo();
}
inline const ::CSDecorateBagInfo& CSDecorateBagVIPFetchRsp::decoratebaginfo() const {
  return decoratebaginfo_ != NULL ? *decoratebaginfo_ : *default_instance_->decoratebaginfo_;
}
inline ::CSDecorateBagInfo* CSDecorateBagVIPFetchRsp::mutable_decoratebaginfo() {
  set_has_decoratebaginfo();
  if (decoratebaginfo_ == NULL) decoratebaginfo_ = new ::CSDecorateBagInfo;
  return decoratebaginfo_;
}
inline ::CSDecorateBagInfo* CSDecorateBagVIPFetchRsp::release_decoratebaginfo() {
  clear_has_decoratebaginfo();
  ::CSDecorateBagInfo* temp = decoratebaginfo_;
  decoratebaginfo_ = NULL;
  return temp;
}
inline void CSDecorateBagVIPFetchRsp::set_allocated_decoratebaginfo(::CSDecorateBagInfo* decoratebaginfo) {
  delete decoratebaginfo_;
  decoratebaginfo_ = decoratebaginfo;
  if (decoratebaginfo) {
    set_has_decoratebaginfo();
  } else {
    clear_has_decoratebaginfo();
  }
}

// optional .CSDecorateBagVIPList VipList = 4;
inline bool CSDecorateBagVIPFetchRsp::has_viplist() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSDecorateBagVIPFetchRsp::set_has_viplist() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSDecorateBagVIPFetchRsp::clear_has_viplist() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSDecorateBagVIPFetchRsp::clear_viplist() {
  if (viplist_ != NULL) viplist_->::CSDecorateBagVIPList::Clear();
  clear_has_viplist();
}
inline const ::CSDecorateBagVIPList& CSDecorateBagVIPFetchRsp::viplist() const {
  return viplist_ != NULL ? *viplist_ : *default_instance_->viplist_;
}
inline ::CSDecorateBagVIPList* CSDecorateBagVIPFetchRsp::mutable_viplist() {
  set_has_viplist();
  if (viplist_ == NULL) viplist_ = new ::CSDecorateBagVIPList;
  return viplist_;
}
inline ::CSDecorateBagVIPList* CSDecorateBagVIPFetchRsp::release_viplist() {
  clear_has_viplist();
  ::CSDecorateBagVIPList* temp = viplist_;
  viplist_ = NULL;
  return temp;
}
inline void CSDecorateBagVIPFetchRsp::set_allocated_viplist(::CSDecorateBagVIPList* viplist) {
  delete viplist_;
  viplist_ = viplist;
  if (viplist) {
    set_has_viplist();
  } else {
    clear_has_viplist();
  }
}

// -------------------------------------------------------------------

// CSDecorateBagReqParam

// optional .CSDecorateBagFetchReq FetchReq = 1;
inline bool CSDecorateBagReqParam::has_fetchreq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDecorateBagReqParam::set_has_fetchreq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDecorateBagReqParam::clear_has_fetchreq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDecorateBagReqParam::clear_fetchreq() {
  if (fetchreq_ != NULL) fetchreq_->::CSDecorateBagFetchReq::Clear();
  clear_has_fetchreq();
}
inline const ::CSDecorateBagFetchReq& CSDecorateBagReqParam::fetchreq() const {
  return fetchreq_ != NULL ? *fetchreq_ : *default_instance_->fetchreq_;
}
inline ::CSDecorateBagFetchReq* CSDecorateBagReqParam::mutable_fetchreq() {
  set_has_fetchreq();
  if (fetchreq_ == NULL) fetchreq_ = new ::CSDecorateBagFetchReq;
  return fetchreq_;
}
inline ::CSDecorateBagFetchReq* CSDecorateBagReqParam::release_fetchreq() {
  clear_has_fetchreq();
  ::CSDecorateBagFetchReq* temp = fetchreq_;
  fetchreq_ = NULL;
  return temp;
}
inline void CSDecorateBagReqParam::set_allocated_fetchreq(::CSDecorateBagFetchReq* fetchreq) {
  delete fetchreq_;
  fetchreq_ = fetchreq;
  if (fetchreq) {
    set_has_fetchreq();
  } else {
    clear_has_fetchreq();
  }
}

// optional .CSDecorateBagShowSetReq ShowSetReq = 2;
inline bool CSDecorateBagReqParam::has_showsetreq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDecorateBagReqParam::set_has_showsetreq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDecorateBagReqParam::clear_has_showsetreq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDecorateBagReqParam::clear_showsetreq() {
  if (showsetreq_ != NULL) showsetreq_->::CSDecorateBagShowSetReq::Clear();
  clear_has_showsetreq();
}
inline const ::CSDecorateBagShowSetReq& CSDecorateBagReqParam::showsetreq() const {
  return showsetreq_ != NULL ? *showsetreq_ : *default_instance_->showsetreq_;
}
inline ::CSDecorateBagShowSetReq* CSDecorateBagReqParam::mutable_showsetreq() {
  set_has_showsetreq();
  if (showsetreq_ == NULL) showsetreq_ = new ::CSDecorateBagShowSetReq;
  return showsetreq_;
}
inline ::CSDecorateBagShowSetReq* CSDecorateBagReqParam::release_showsetreq() {
  clear_has_showsetreq();
  ::CSDecorateBagShowSetReq* temp = showsetreq_;
  showsetreq_ = NULL;
  return temp;
}
inline void CSDecorateBagReqParam::set_allocated_showsetreq(::CSDecorateBagShowSetReq* showsetreq) {
  delete showsetreq_;
  showsetreq_ = showsetreq;
  if (showsetreq) {
    set_has_showsetreq();
  } else {
    clear_has_showsetreq();
  }
}

// optional .CSDecorateBagVIPFetchReq VIPFetchReq = 3;
inline bool CSDecorateBagReqParam::has_vipfetchreq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSDecorateBagReqParam::set_has_vipfetchreq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSDecorateBagReqParam::clear_has_vipfetchreq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSDecorateBagReqParam::clear_vipfetchreq() {
  if (vipfetchreq_ != NULL) vipfetchreq_->::CSDecorateBagVIPFetchReq::Clear();
  clear_has_vipfetchreq();
}
inline const ::CSDecorateBagVIPFetchReq& CSDecorateBagReqParam::vipfetchreq() const {
  return vipfetchreq_ != NULL ? *vipfetchreq_ : *default_instance_->vipfetchreq_;
}
inline ::CSDecorateBagVIPFetchReq* CSDecorateBagReqParam::mutable_vipfetchreq() {
  set_has_vipfetchreq();
  if (vipfetchreq_ == NULL) vipfetchreq_ = new ::CSDecorateBagVIPFetchReq;
  return vipfetchreq_;
}
inline ::CSDecorateBagVIPFetchReq* CSDecorateBagReqParam::release_vipfetchreq() {
  clear_has_vipfetchreq();
  ::CSDecorateBagVIPFetchReq* temp = vipfetchreq_;
  vipfetchreq_ = NULL;
  return temp;
}
inline void CSDecorateBagReqParam::set_allocated_vipfetchreq(::CSDecorateBagVIPFetchReq* vipfetchreq) {
  delete vipfetchreq_;
  vipfetchreq_ = vipfetchreq;
  if (vipfetchreq) {
    set_has_vipfetchreq();
  } else {
    clear_has_vipfetchreq();
  }
}

// -------------------------------------------------------------------

// CSDecorateBagRspParam

// optional .CSDecorateBagFetchRsp FetchRsp = 1;
inline bool CSDecorateBagRspParam::has_fetchrsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDecorateBagRspParam::set_has_fetchrsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDecorateBagRspParam::clear_has_fetchrsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDecorateBagRspParam::clear_fetchrsp() {
  if (fetchrsp_ != NULL) fetchrsp_->::CSDecorateBagFetchRsp::Clear();
  clear_has_fetchrsp();
}
inline const ::CSDecorateBagFetchRsp& CSDecorateBagRspParam::fetchrsp() const {
  return fetchrsp_ != NULL ? *fetchrsp_ : *default_instance_->fetchrsp_;
}
inline ::CSDecorateBagFetchRsp* CSDecorateBagRspParam::mutable_fetchrsp() {
  set_has_fetchrsp();
  if (fetchrsp_ == NULL) fetchrsp_ = new ::CSDecorateBagFetchRsp;
  return fetchrsp_;
}
inline ::CSDecorateBagFetchRsp* CSDecorateBagRspParam::release_fetchrsp() {
  clear_has_fetchrsp();
  ::CSDecorateBagFetchRsp* temp = fetchrsp_;
  fetchrsp_ = NULL;
  return temp;
}
inline void CSDecorateBagRspParam::set_allocated_fetchrsp(::CSDecorateBagFetchRsp* fetchrsp) {
  delete fetchrsp_;
  fetchrsp_ = fetchrsp;
  if (fetchrsp) {
    set_has_fetchrsp();
  } else {
    clear_has_fetchrsp();
  }
}

// optional .CSDecorateBagVIPFetchRsp VIPFetchRsp = 2;
inline bool CSDecorateBagRspParam::has_vipfetchrsp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDecorateBagRspParam::set_has_vipfetchrsp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDecorateBagRspParam::clear_has_vipfetchrsp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDecorateBagRspParam::clear_vipfetchrsp() {
  if (vipfetchrsp_ != NULL) vipfetchrsp_->::CSDecorateBagVIPFetchRsp::Clear();
  clear_has_vipfetchrsp();
}
inline const ::CSDecorateBagVIPFetchRsp& CSDecorateBagRspParam::vipfetchrsp() const {
  return vipfetchrsp_ != NULL ? *vipfetchrsp_ : *default_instance_->vipfetchrsp_;
}
inline ::CSDecorateBagVIPFetchRsp* CSDecorateBagRspParam::mutable_vipfetchrsp() {
  set_has_vipfetchrsp();
  if (vipfetchrsp_ == NULL) vipfetchrsp_ = new ::CSDecorateBagVIPFetchRsp;
  return vipfetchrsp_;
}
inline ::CSDecorateBagVIPFetchRsp* CSDecorateBagRspParam::release_vipfetchrsp() {
  clear_has_vipfetchrsp();
  ::CSDecorateBagVIPFetchRsp* temp = vipfetchrsp_;
  vipfetchrsp_ = NULL;
  return temp;
}
inline void CSDecorateBagRspParam::set_allocated_vipfetchrsp(::CSDecorateBagVIPFetchRsp* vipfetchrsp) {
  delete vipfetchrsp_;
  vipfetchrsp_ = vipfetchrsp;
  if (vipfetchrsp) {
    set_has_vipfetchrsp();
  } else {
    clear_has_vipfetchrsp();
  }
}

// -------------------------------------------------------------------

// CSDecorateBagReq

// required .CSDecorateBagCmd cmd = 1;
inline bool CSDecorateBagReq::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDecorateBagReq::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDecorateBagReq::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDecorateBagReq::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::CSDecorateBagCmd CSDecorateBagReq::cmd() const {
  return static_cast< ::CSDecorateBagCmd >(cmd_);
}
inline void CSDecorateBagReq::set_cmd(::CSDecorateBagCmd value) {
  assert(::CSDecorateBagCmd_IsValid(value));
  set_has_cmd();
  cmd_ = value;
}

// optional .CSDecorateBagReqParam reqParam = 2;
inline bool CSDecorateBagReq::has_reqparam() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDecorateBagReq::set_has_reqparam() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDecorateBagReq::clear_has_reqparam() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDecorateBagReq::clear_reqparam() {
  if (reqparam_ != NULL) reqparam_->::CSDecorateBagReqParam::Clear();
  clear_has_reqparam();
}
inline const ::CSDecorateBagReqParam& CSDecorateBagReq::reqparam() const {
  return reqparam_ != NULL ? *reqparam_ : *default_instance_->reqparam_;
}
inline ::CSDecorateBagReqParam* CSDecorateBagReq::mutable_reqparam() {
  set_has_reqparam();
  if (reqparam_ == NULL) reqparam_ = new ::CSDecorateBagReqParam;
  return reqparam_;
}
inline ::CSDecorateBagReqParam* CSDecorateBagReq::release_reqparam() {
  clear_has_reqparam();
  ::CSDecorateBagReqParam* temp = reqparam_;
  reqparam_ = NULL;
  return temp;
}
inline void CSDecorateBagReq::set_allocated_reqparam(::CSDecorateBagReqParam* reqparam) {
  delete reqparam_;
  reqparam_ = reqparam;
  if (reqparam) {
    set_has_reqparam();
  } else {
    clear_has_reqparam();
  }
}

// -------------------------------------------------------------------

// CSDecorateBagRsp

// optional int32 result = 1;
inline bool CSDecorateBagRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDecorateBagRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDecorateBagRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDecorateBagRsp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CSDecorateBagRsp::result() const {
  return result_;
}
inline void CSDecorateBagRsp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required .CSDecorateBagCmd cmd = 2;
inline bool CSDecorateBagRsp::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDecorateBagRsp::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDecorateBagRsp::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDecorateBagRsp::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::CSDecorateBagCmd CSDecorateBagRsp::cmd() const {
  return static_cast< ::CSDecorateBagCmd >(cmd_);
}
inline void CSDecorateBagRsp::set_cmd(::CSDecorateBagCmd value) {
  assert(::CSDecorateBagCmd_IsValid(value));
  set_has_cmd();
  cmd_ = value;
}

// optional .CSDecorateBagRspParam rspParam = 3;
inline bool CSDecorateBagRsp::has_rspparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSDecorateBagRsp::set_has_rspparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSDecorateBagRsp::clear_has_rspparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSDecorateBagRsp::clear_rspparam() {
  if (rspparam_ != NULL) rspparam_->::CSDecorateBagRspParam::Clear();
  clear_has_rspparam();
}
inline const ::CSDecorateBagRspParam& CSDecorateBagRsp::rspparam() const {
  return rspparam_ != NULL ? *rspparam_ : *default_instance_->rspparam_;
}
inline ::CSDecorateBagRspParam* CSDecorateBagRsp::mutable_rspparam() {
  set_has_rspparam();
  if (rspparam_ == NULL) rspparam_ = new ::CSDecorateBagRspParam;
  return rspparam_;
}
inline ::CSDecorateBagRspParam* CSDecorateBagRsp::release_rspparam() {
  clear_has_rspparam();
  ::CSDecorateBagRspParam* temp = rspparam_;
  rspparam_ = NULL;
  return temp;
}
inline void CSDecorateBagRsp::set_allocated_rspparam(::CSDecorateBagRspParam* rspparam) {
  delete rspparam_;
  rspparam_ = rspparam;
  if (rspparam) {
    set_has_rspparam();
  } else {
    clear_has_rspparam();
  }
}

// -------------------------------------------------------------------

// CSMsgBody

// optional .CSRegisterLoginReq RegisterLoginReq = 1;
inline bool CSMsgBody::has_registerloginreq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMsgBody::set_has_registerloginreq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMsgBody::clear_has_registerloginreq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMsgBody::clear_registerloginreq() {
  if (registerloginreq_ != NULL) registerloginreq_->::CSRegisterLoginReq::Clear();
  clear_has_registerloginreq();
}
inline const ::CSRegisterLoginReq& CSMsgBody::registerloginreq() const {
  return registerloginreq_ != NULL ? *registerloginreq_ : *default_instance_->registerloginreq_;
}
inline ::CSRegisterLoginReq* CSMsgBody::mutable_registerloginreq() {
  set_has_registerloginreq();
  if (registerloginreq_ == NULL) registerloginreq_ = new ::CSRegisterLoginReq;
  return registerloginreq_;
}
inline ::CSRegisterLoginReq* CSMsgBody::release_registerloginreq() {
  clear_has_registerloginreq();
  ::CSRegisterLoginReq* temp = registerloginreq_;
  registerloginreq_ = NULL;
  return temp;
}
inline void CSMsgBody::set_allocated_registerloginreq(::CSRegisterLoginReq* registerloginreq) {
  delete registerloginreq_;
  registerloginreq_ = registerloginreq;
  if (registerloginreq) {
    set_has_registerloginreq();
  } else {
    clear_has_registerloginreq();
  }
}

// optional .CSRegisterLoginRsp RegisterLoginRsp = 2;
inline bool CSMsgBody::has_registerloginrsp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMsgBody::set_has_registerloginrsp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMsgBody::clear_has_registerloginrsp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMsgBody::clear_registerloginrsp() {
  if (registerloginrsp_ != NULL) registerloginrsp_->::CSRegisterLoginRsp::Clear();
  clear_has_registerloginrsp();
}
inline const ::CSRegisterLoginRsp& CSMsgBody::registerloginrsp() const {
  return registerloginrsp_ != NULL ? *registerloginrsp_ : *default_instance_->registerloginrsp_;
}
inline ::CSRegisterLoginRsp* CSMsgBody::mutable_registerloginrsp() {
  set_has_registerloginrsp();
  if (registerloginrsp_ == NULL) registerloginrsp_ = new ::CSRegisterLoginRsp;
  return registerloginrsp_;
}
inline ::CSRegisterLoginRsp* CSMsgBody::release_registerloginrsp() {
  clear_has_registerloginrsp();
  ::CSRegisterLoginRsp* temp = registerloginrsp_;
  registerloginrsp_ = NULL;
  return temp;
}
inline void CSMsgBody::set_allocated_registerloginrsp(::CSRegisterLoginRsp* registerloginrsp) {
  delete registerloginrsp_;
  registerloginrsp_ = registerloginrsp;
  if (registerloginrsp) {
    set_has_registerloginrsp();
  } else {
    clear_has_registerloginrsp();
  }
}

// optional .CSBagReq BagReq = 3;
inline bool CSMsgBody::has_bagreq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMsgBody::set_has_bagreq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMsgBody::clear_has_bagreq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMsgBody::clear_bagreq() {
  if (bagreq_ != NULL) bagreq_->::CSBagReq::Clear();
  clear_has_bagreq();
}
inline const ::CSBagReq& CSMsgBody::bagreq() const {
  return bagreq_ != NULL ? *bagreq_ : *default_instance_->bagreq_;
}
inline ::CSBagReq* CSMsgBody::mutable_bagreq() {
  set_has_bagreq();
  if (bagreq_ == NULL) bagreq_ = new ::CSBagReq;
  return bagreq_;
}
inline ::CSBagReq* CSMsgBody::release_bagreq() {
  clear_has_bagreq();
  ::CSBagReq* temp = bagreq_;
  bagreq_ = NULL;
  return temp;
}
inline void CSMsgBody::set_allocated_bagreq(::CSBagReq* bagreq) {
  delete bagreq_;
  bagreq_ = bagreq;
  if (bagreq) {
    set_has_bagreq();
  } else {
    clear_has_bagreq();
  }
}

// optional .CSBagRsp BagRsp = 4;
inline bool CSMsgBody::has_bagrsp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSMsgBody::set_has_bagrsp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSMsgBody::clear_has_bagrsp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSMsgBody::clear_bagrsp() {
  if (bagrsp_ != NULL) bagrsp_->::CSBagRsp::Clear();
  clear_has_bagrsp();
}
inline const ::CSBagRsp& CSMsgBody::bagrsp() const {
  return bagrsp_ != NULL ? *bagrsp_ : *default_instance_->bagrsp_;
}
inline ::CSBagRsp* CSMsgBody::mutable_bagrsp() {
  set_has_bagrsp();
  if (bagrsp_ == NULL) bagrsp_ = new ::CSBagRsp;
  return bagrsp_;
}
inline ::CSBagRsp* CSMsgBody::release_bagrsp() {
  clear_has_bagrsp();
  ::CSBagRsp* temp = bagrsp_;
  bagrsp_ = NULL;
  return temp;
}
inline void CSMsgBody::set_allocated_bagrsp(::CSBagRsp* bagrsp) {
  delete bagrsp_;
  bagrsp_ = bagrsp;
  if (bagrsp) {
    set_has_bagrsp();
  } else {
    clear_has_bagrsp();
  }
}

// optional .CSDecorateBagReq DecorateBagReq = 5;
inline bool CSMsgBody::has_decoratebagreq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSMsgBody::set_has_decoratebagreq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSMsgBody::clear_has_decoratebagreq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSMsgBody::clear_decoratebagreq() {
  if (decoratebagreq_ != NULL) decoratebagreq_->::CSDecorateBagReq::Clear();
  clear_has_decoratebagreq();
}
inline const ::CSDecorateBagReq& CSMsgBody::decoratebagreq() const {
  return decoratebagreq_ != NULL ? *decoratebagreq_ : *default_instance_->decoratebagreq_;
}
inline ::CSDecorateBagReq* CSMsgBody::mutable_decoratebagreq() {
  set_has_decoratebagreq();
  if (decoratebagreq_ == NULL) decoratebagreq_ = new ::CSDecorateBagReq;
  return decoratebagreq_;
}
inline ::CSDecorateBagReq* CSMsgBody::release_decoratebagreq() {
  clear_has_decoratebagreq();
  ::CSDecorateBagReq* temp = decoratebagreq_;
  decoratebagreq_ = NULL;
  return temp;
}
inline void CSMsgBody::set_allocated_decoratebagreq(::CSDecorateBagReq* decoratebagreq) {
  delete decoratebagreq_;
  decoratebagreq_ = decoratebagreq;
  if (decoratebagreq) {
    set_has_decoratebagreq();
  } else {
    clear_has_decoratebagreq();
  }
}

// optional .CSDecorateBagRsp DecorateBagRsp = 6;
inline bool CSMsgBody::has_decoratebagrsp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSMsgBody::set_has_decoratebagrsp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSMsgBody::clear_has_decoratebagrsp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSMsgBody::clear_decoratebagrsp() {
  if (decoratebagrsp_ != NULL) decoratebagrsp_->::CSDecorateBagRsp::Clear();
  clear_has_decoratebagrsp();
}
inline const ::CSDecorateBagRsp& CSMsgBody::decoratebagrsp() const {
  return decoratebagrsp_ != NULL ? *decoratebagrsp_ : *default_instance_->decoratebagrsp_;
}
inline ::CSDecorateBagRsp* CSMsgBody::mutable_decoratebagrsp() {
  set_has_decoratebagrsp();
  if (decoratebagrsp_ == NULL) decoratebagrsp_ = new ::CSDecorateBagRsp;
  return decoratebagrsp_;
}
inline ::CSDecorateBagRsp* CSMsgBody::release_decoratebagrsp() {
  clear_has_decoratebagrsp();
  ::CSDecorateBagRsp* temp = decoratebagrsp_;
  decoratebagrsp_ = NULL;
  return temp;
}
inline void CSMsgBody::set_allocated_decoratebagrsp(::CSDecorateBagRsp* decoratebagrsp) {
  delete decoratebagrsp_;
  decoratebagrsp_ = decoratebagrsp;
  if (decoratebagrsp) {
    set_has_decoratebagrsp();
  } else {
    clear_has_decoratebagrsp();
  }
}

// -------------------------------------------------------------------

// CSMsgHead

// required uint64 uid = 1;
inline bool CSMsgHead::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMsgHead::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMsgHead::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMsgHead::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 CSMsgHead::uid() const {
  return uid_;
}
inline void CSMsgHead::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required .CSMsgID msgID = 2;
inline bool CSMsgHead::has_msgid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMsgHead::set_has_msgid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMsgHead::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMsgHead::clear_msgid() {
  msgid_ = 0;
  clear_has_msgid();
}
inline ::CSMsgID CSMsgHead::msgid() const {
  return static_cast< ::CSMsgID >(msgid_);
}
inline void CSMsgHead::set_msgid(::CSMsgID value) {
  assert(::CSMsgID_IsValid(value));
  set_has_msgid();
  msgid_ = value;
}

// -------------------------------------------------------------------

// CSMsg

// required .CSMsgHead head = 1;
inline bool CSMsg::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMsg::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMsg::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMsg::clear_head() {
  if (head_ != NULL) head_->::CSMsgHead::Clear();
  clear_has_head();
}
inline const ::CSMsgHead& CSMsg::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::CSMsgHead* CSMsg::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::CSMsgHead;
  return head_;
}
inline ::CSMsgHead* CSMsg::release_head() {
  clear_has_head();
  ::CSMsgHead* temp = head_;
  head_ = NULL;
  return temp;
}
inline void CSMsg::set_allocated_head(::CSMsgHead* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// required .CSMsgBody body = 2;
inline bool CSMsg::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMsg::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMsg::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMsg::clear_body() {
  if (body_ != NULL) body_->::CSMsgBody::Clear();
  clear_has_body();
}
inline const ::CSMsgBody& CSMsg::body() const {
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::CSMsgBody* CSMsg::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::CSMsgBody;
  return body_;
}
inline ::CSMsgBody* CSMsg::release_body() {
  clear_has_body();
  ::CSMsgBody* temp = body_;
  body_ = NULL;
  return temp;
}
inline void CSMsg::set_allocated_body(::CSMsgBody* body) {
  delete body_;
  body_ = body;
  if (body) {
    set_has_body();
  } else {
    clear_has_body();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CSRegisterLoginCmd>() {
  return ::CSRegisterLoginCmd_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CSBagCmd>() {
  return ::CSBagCmd_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CSDecorateBagCmd>() {
  return ::CSDecorateBagCmd_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CSMsgID>() {
  return ::CSMsgID_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSmsg_2eproto__INCLUDED
